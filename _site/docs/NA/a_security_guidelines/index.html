<!DOCTYPE html>
<html lang="en">

    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Developing Secure Ledger Apps | Ledger Developer pages</title>
<meta name="generator" content="Jekyll v3.9.1" />
<meta property="og:title" content="Developing Secure Ledger Apps" />
<meta name="author" content="pscott" />
<meta property="og:locale" content="en" />
<meta name="description" content="Sections in this article Introduction Development practices Code reviews Security audits Developing First App Cryptography Own crypto primitives Avoid blindly signing data Restrict Apps to Coin-Specific BIP32 Prefix Signing/disclosing keys without user approval Private Key Management Be Wary of Untrusted Input Properly protect data you wish to cache on the host computer Do not allow the host to freely manipulate with key-pairs C is your enemy Know your C compiler Use safe macro constructs Buffer overflows/underflows Integer overflows/underflows Data Truncation Stack overflow Optimizations Business logic problems Swallowing errors &amp; half-updated states Too lenient parsing of transactions Protect Against “Instruction Change” Attacks Example: Two multi-APDU instructions Example: Single multi-APDU instruction Example: “Self”-attack on a single multi-APDU instruction Use explicit state machines Introduction Developing applications for Ledger devices (Nano S, X, Blue) is an intricate process. The security of the user funds relies on the fact that the application works in a correct and secure manner and that potential attackers cannot misuse it to extract private data and/or sign requests which are not authorized by the user. The app should guard against such attacks because they have a very low entry point – a Ledger device attached to a compromised host might be a victim of the attacker’s program sending invalid/non-standard requests to the device. This guide is meant to be a summary of all important aspects of Ledger Apps security and it shall be read by developers before developing an app for Ledger. The guide is divided into multiple sections, each taking on a different aspect of security. Development practices Whenever writing a secure Ledger app, the following advice should not be taken lightly. Code reviews We encourage all written code to be peer-reviewed. Importantly, the review should have at least: One reviewer proficient in C and knowing C security weaknesses. One reviewer with “hacker’s mind” (looking at the code from the perspective of an attacker). Security audits We encourage third-party security reviews. Note, however, that solid review takes time and a short review might yield a false sense of security (especially if the reviewing party does not have an extensive knowledge of Ledger code specifics). Developing First App Apart from reading developer documentation at https://ledger.readthedocs.io/en/latest/ we recommend looking at Sia app https://github.com/LedgerHQ/ledger-app-sia which provides a nice starting point for an app, including lots of explanatory comments. A sample of security-wise overly-paranoid app is https://github.com/LedgerHQ/ledger-app-cardano. Cryptography This section presents general concepts about cryptography development, but also guidelines specific to the security model of the Ledger devices. It gives guidelines to: Ensure a potential vulnerability in one application will not cause damages to other apps. Make sure all the operations that manipulate secrets are approved by the user. Restrict the use of these secrets by apps. Own crypto primitives You should never roll your own crypto primitives (including encryption/derivation schemes, hashing functions, HMAC, etc.) Rationale: It is a purpose of BOLOS operating system to perform these in a secure manner. Importantly, writing your own crypto primitives is likely to open you to side-channel attacks or other problems. If your primitive is not supported by BOLOS (e.g., some very new cryptography), consult with Ledger developers the possibility of including it in the OS. Avoid blindly signing data You should never allow signing of any attacker-controlled message unless it has been verified for structural validity. Importantly, you should never sign a message that might be a hash of transaction. Rationale: If you allow an attacker to blindly sign a message, she can easily supply a hash of a valid transaction. Your signature could then be used to send an unauthorized transaction. If you want to sign user-supplied “personal” messages, prefix them with a fixed string (which shouldn’t be a valid transaction prefix). It is also a good practice to include message length in the text to be signed. Ledger-app-eth has a good example in function handleSignPersonalMessage. Note that sometimes cryptocurrencies have a standardized way of signing such personal messages and in that case you should use the approved scheme. Warning: If you allow signing untrusted hashes (while displaying a prompt to the user), be aware that Users do not understand security and could be easily tricked. In fact, they will probably click through your prompt without thinking unless you give them explicit “Warning: this is a very unusual operation. Do not continue unless you know what you are doing” warning. They might not listen even then A compromised host might both change hash on the screen and also data sent to device. This opens the possibility of users signing something they didn’t want to. Restrict Apps to Coin-Specific BIP32 Prefix BIP32 paths on which the app can derive keys must be restricted in your application. The chosen derivation paths must not conflict with existing paths if the use case differs. Warning Ledger will not sign apps whose BIP32 prefixes have not been properly set. Restricting the derivation path can be done by setting the --path property in the app Makefile. For example, if your application derive keys on the hardened path 44’/60’, specify in your Makefile: APP_LOAD_PARAMS += --path &quot;44&#39;/60&#39;&quot; Derivation can also be restricted to a specific curve using the --curve property. Supported curves are secp256k1, prime256r1 and ed25519. Several curves and paths can be configured. For example, if your app must derive keys on paths 44’/535348’, 13’ and 17’, on curves Ed25519 and prime256r1, the Makefile should contain: APP_LOAD_PARAMS=--curve ed25519 --curve prime256r1 --path &quot;44&#39;/535348&#39;&quot; --path &quot;13&#39;&quot; --path &quot;17&#39;&quot; Rationale: Setting prefixes is crucial, as it limites the amount of damages an attacker can do if he manages to compromise an application. If a vulnerability is exploited on a poorly written of backdoored application, an attacker should not be able to exploit it to extract private keys from other apps, such as Bitcoin or Ethereum keys. Warning If your application derives keys on the hardened path 44&#39;/60&#39; then the chainID parameter must be different from 0 or 1. This is necessary to avoid replaying transactions broadcoast on Ethereum-like chains on Ethereum. As a general recommendation, and to ensure a good level of privacy for the end user, we recommend to always use the correct coin type in the derivation path as defined in slip44 (&lt;https://github.com/satoshilabs/slips/blob/master/slip-0044.md&gt;) Signing/disclosing keys without user approval Warning You must always require user approval for signing transactions/messages. Rationale: If you do not require user consent for signing important data, an attacker can use your device as a signing black box and sign whatever it wants. Note You might also consider approvals for extracting public keys, as some users might want extended privacy. 1. They might not want to reveal their *root/account* public key, only address keys 2. They might not want to reveal address public key until it is required. (Some cryptocurrencies use addresses that are hash of public keys. It is therefore enough to send the address to the host). Note that there is a trade-off between privacy and usability here. If you want privacy, it would require a user interaction every time they want to use Ledger device, as opposed to only interaction while signing transactions. The behaviour could also be manually set in the application options. Private Key Management You should minimize the code that works with private (ECDSA, RSA, etc.) or secret (HMAC, AES, etc.) keys. Importantly, you should always clear the memory after you use these keys. That includes key data and key objects. Leaving parts of private or secret keys lying around in memory is not a security issue on its own because there is no easy way to extract the content of RAM on the chip. If a key is left in RAM by an app, another app will not be able to access it. However, if the key has not been properly erased, a security issue could lead to the leak of this key, even if it is not used anymore. An attacker able to read arbitrary memory from the app, or execute arbitrary code, will be able to read the content of the stack segment, hence the parts of the key which have not been erased. A common (and wrong) way of doing this: uint8_t privateKeyData[64]; cx_ecfp_private_key_t privateKey; os_perso_derive_node_bip32( tmpCtx.transactionContext.curve, tmpCtx.transactionContext.bip32Path, tmpCtx.transactionContext.pathLength, privateKeyData, NULL); cx_ecfp_init_private_key(tmpCtx.transactionContext.curve, privateKeyData, 32, &amp;privateKey); explicit_bzero(privateKeyData, sizeof(privateKeyData)); // (later, after privateKey is not needed) explicit_bzero(&amp;privateKey, sizeof(privateKey)); In the happy path, the previous code will correctly clean the memory once the private key is initialized. Note, however, that this code fails to protect private key in case some system call throws (for example cx_ecfp_init_private_key). Correct code should wrap the clearing in BEGIN_TRY { TRY { ... } FINALLY { explicit_bzero() } END_TRY;. Applications where such issues were fixed include the ARK app and the Solana app. Be Wary of Untrusted Input Some cryptocurrencies do not have explicit fee encoded in the transaction. In such cases, the app cannot rely on fee value sent from the host. Instead, it should receive previous UTxOs and check their output amounts. Note that this usually needs to be done in a separate step due to memory constraints. Check with BTC/Cardano app design for this. Properly protect data you wish to cache on the host computer Sometimes your app needs to compute over more data than it can fit inside memory. Taking an example from the previous section, it might not be easy to store all UTxOs in memory of Ledger. As such, you might break computation into multiple steps and, for example, verify each UTxO separately and let the host computer to cache a “certified summary”. If you do this, be aware that If the information you want the host to cache is public, you still need to attach a signature to it so that the host cannot send some other value later. This could be done with standard HMAC digest. We would recommend using a temporary (per session) key for this –having a per-session HMAC allows you to truncate the digest size (e.g., you don’t need to have HMAC which withstands years of brute-force attack. Instead, you can balance the digest size against some reasonable upper bound on how long the session lives (e.g., one month should be enough)). If the information is not public, you need to both encrypt and provide a signature. Notably, it is not enough to “scramble” the data by XORing with a random key as this would still allow the attacker to tamper with the values. (Or even break the scrambling if you re-use the same key). Instead: Encrypt the information with a sufficiently strong cipher Provide a digest to avoid tampering with the value Do not allow the host to freely manipulate with key-pairs Some cryptocurrencies (notably Monero) need to perform an extensive calculation with (public, private) key-pair spread over multiple APDU exchanges. If you need to do the same, do not allow the attacker to step out of the protocol. Notably, allowing the attacker to freely perform key manipulation (e.g., group multiplications, exponentiations, etc.) could undermine your app security even if the private key never leaves the device. In general, keep an explicit protocol state machine during the computation. Also, consult with cryptography experts to check for implications if you misstep from the protocol. C is your enemy Know your C compiler Ledger apps are written in C. Unlike typical embedded project, the goal here is to write for a single platform with a single compiler. The current supported compiler is clang, and it supports newest language features (up to C11). This is useful for both development and security. You should really learn about the new features and use them extensively as they might help you writing more secure code. A random collection of useful features: intermingled declarations and code, support of _Generic, _Static_assert, __builtin_types_compatible_p, __typeof (very useful for safer versions of macros), etc. Use safe macro constructs C is a minefield of problems related to pointers. You can alleviate some of the problems with good macros. However, beware of when they can fail. For example, take the following code: #define ARRAY_LEN(a) sizeof(a) / sizeof(a[0]) Apart from the “obvious” problem of ARRAY_LEN macro being written without external parenthesis, making code such as (uint8_t) ARRAY_LEN(x) compile to what is understood by the compiler as (uint8_t) sizeof(x) / sizeof(x[0]) there is an important problem with this macro. If used in the function like this void fn(int x[10]) { int len = ARRAY_LEN(x) } The result is unexpectedly len=1. The reason is that int x[10] in the function header is silently converted into int* x and the length is therefore sizeof(ptr) / sizeof(int) which is indeed 1 on the platform. You can read more about the problem and how to define a safe version in http://zubplot.blogspot.com/2015/01/gcc-is-wonderful-better-arraysize-macro.html which explains a patch to the Linux kernel to improve safety of its ARRAY_SIZE macro. Note that similar problems exist, if x is a pointer, with: memset(x, 0, sizeof(x)) In general, if writing macros, try to write them in a way that they will fail if they get a pointer instead of struct/array. Buffer overflows/underflows Buffer overflows and underflows are perhaps the biggest source of security vulnerabilities in C code. The following example shows a buffer overflow in (a past version) of one Ledger app. #define MAX_RAW_TX 200 ... struct tmpCtx { ... uint8_t rawTx[MAX_RAW_TX]; } transactionContext_t; const uint8_t PREFIX[] = {0x00, 0x01, 0x02 ... } // coin-specific signing prefix void handleSign(uint8_t p1, uint8_t p2, uint8_t *workBuffer, uint16_t dataLength, volatile unsigned int *flags, volatile unsigned int *tx) { ... // (no dataLength validation, we can get up to 255 from APDU) // Note: we can pass this line with dataLength &gt; 200 if (parseTx(workBuffer, dataLength, &amp;txContent) != USTREAM_FINISHED) { THROW(0x6A80); } ... memmove(tmpCtx.rawTx, PREFIX, sizeof(PREFIX)); // Here is the vulnerability. There should be a check of // if (!(dataLength + sizeof(SIGN_PREFIX) &lt; MAX_RAW_TX)) THROW(...) memmove(tmpCtx.transactionContext.rawTx + sizeof(SIGN_PREFIX), workBuffer, dataLength); } In general, there is only a single remedy for buffer overflows -always check for available buffer space before writing to memory. The best is to not rely on some specific buffer size but instead rely on sizeof operator. If using sizeof, however, be very careful - if you ever pass a buffer to a function, you are losing its size! uint8_t a[100]; main() { sizeof(a); // 100 f(a); g(a); } void f(uint8_t* x) { sizeof(x); // 4 } void g(uint8_t oops[100]) { sizeof(oops); // 4 } For the extra safery, consider using a SIZEOF macro defined similarly to https://github.com/LedgerHQ/ledger-app-cardano/blob/f578c903c19288495a359a2bc909b39c33ee69ca/src/utils.h#L27 Be also wary of constructs like memset(displayAddress, 0, sizeof(fullAddress)); memmove((void *)displayAddress, tmpCtx.address, 5); memmove((void *)(displayAddress + 5), &quot;...&quot;, 3); memmove((void *)(displayAddress + 8), tmpCtx.address + addressLength - 4, 4); There are several problematic aspects of such code. Apart from truncating important values (see next sections), this code makes a lot of assumptions. For example, if addressLength &lt; 4 (maybe some previous function returns addressLength=0 instead of an error) we get buffer underflow and copy up to 4 bytes of other memory and display it to the user. Or a programmer decides to shorten definition of fullAddress below 13 and we would overwrite memory after the buffer. Finally, this code uses explicit indexes (e.g., 5, 8=5+3). A better trick would be to have a safe helper macro: #define APPEND(ptr, end, from, len) \ do { \ if (ptr + len &gt;= end || len &lt; 0) THROW(); // not enough space \ memcpy(ptr, from, len); \ ptr += len; \ } while(0) char* ptr_begin = displayAddress; char* ptr_end = displayAddress + sizeof(displayAddress); // points behind buffer APPEND(ptr_begin, ptr_end, tmpCtx.address, 5); // we should also assert addressLength&gt;5 APPEND(ptr_begin, ptr_end, &quot;...&quot;, 3); // Note, we still have explicit size here APPEND(ptr_begin, ptr_end, tmpCtx.address - 4, 4); // Note: another assert Finally, you can use SPRINTF macro from sdk/include/os_io_seproxyhal.h but be aware that the definition is #define SPRINTF(strbuf, ...) snprintf(strbuf, sizeof(strbuf), __VA_ARGS__) so the above warning about passing pointers instead of arrays applies to it. Integer overflows/underflows Integer overflows go hand in hand with buffer overflows. In fact, they can cause serious buffer overflows. Consider following code where a numeric underflow causes buffer overflow of 64kB! void handleSign(uint8_t p1, uint8_t p2, uint8_t *workBuffer, uint16_t dataLength, volatile unsigned int *flags, volatile unsigned int *tx) { uint32_t i; // here we don&#39;t check if dataLength &gt; 0 so we might be reading behind the buffer tmpCtx.transactionContext.pathLength = workBuffer[0]; if ((tmpCtx.transactionContext.pathLength &lt; 0x01) || (tmpCtx.transactionContext.pathLength &gt; MAX_BIP32_PATH)) { PRINTF(&quot;Invalid path\n&quot;); THROW(0x6a80); } workBuffer++; dataLength--; for (i = 0; i &lt; tmpCtx.transactionContext.pathLength; i++) { tmpCtx.transactionContext.bip32Path[i] = (workBuffer[0] &lt;&lt; 24) | (workBuffer[1] &lt;&lt; 16) | (workBuffer[2] &lt;&lt; 8) | (workBuffer[3]); workBuffer += 4; // here we again blindly assume dataLength &gt;= 4 dataLength -= 4; } initTxContext(&amp;txProcessingCtx, &amp;sha256, &amp;dataSha256, &amp;txContent, N_storage.dataAllowed); // if we sent APDU with dataLength=0 at the beginning, we would end up with dataLength ~ 64kB here txResult = parseTx(&amp;txProcessingCtx, workBuffer, dataLength); ... } As a general rule, be very careful about variables which might overflow or underflow. If possible, use bigger types that can accommodate the arithmetic operations you need to perform. For buffer sizes, prefer unsigned types – that way, you can easily check both overflow and underflow in one go, i.e. void f(uint8_t* buf, size_t bufSize) { // size_t is unsigned if (bufSize &lt; REASONABLE_SIZE) THROW(); // guards both against underflow and overflow! } Data Truncation Speaking of safely formatting data, be wary of truncated values. Importantly, make sure you do not truncate any important data when displaying on the Ledger screen. Example 1: Truncating tx hash from “f6954eb23ecd1d64c782e6d6c32fad2876003ae92986606585ae7187470d5e04” to “f695…5e04” might look nice for the users but this effectively reduces the security of hash and an attacker can now easily try to create a hash collision. Instead, prefer scrolling/paging of long such important values. Example 2: Raise errors instead of truncation int tmp[10]; // max 10 digits, right? uint32_t amount = 1987654321 SPRINTF(tmp, &quot;%d&quot;, amount) // at least we won&#39;t get buffer overflow here ... display(tmp) // but we display an empty screen! // but it could be worse // with bad custom formatting function we could get format_amount(tmp, SIZEOF(tmp), amount) // &quot;198765432&quot; or &quot;987654321&quot; Stack overflow You application has only a limited size (about ~700B) of stack. That is one of the reasons why stack cookies are not supported yet on the platform. Given the memory constraints, BOLOS OS does not have memory mapping which would protect from stack overflow errors. As a result, it is very easy to consume more stack space and overwrite the end of your data. Recommendation: Enable DEFINES += HAVE_BOLOS_APP_STACK_CANARY in your Makefile. This will help you detect stack overflows during app development. If overflow is detected, the app will reboot the device. Note that the overflow check happens only on the next I/O. This means that the protection is not instant and an attacker might avoid the canary check: this option is not a security feature, and has been added to analyze the stack usage during testing process. Optimizations Do not clear sensitive data with for-loops or other techniques. Do not user memset or bzero to clear sensitive data: it could be optimized and removed by the compiler. Recommendation: Use explicit_bzero which guarantees that the compiler will not remove the erasure. (See https://www.owasp.org/index.php/Insecure\_Compiler\_Optimization for an example of how things could go wrong.) Business logic problems Swallowing errors &amp; half-updated states It goes without saying that you should check return value of functions for any errors. Fortunately, BOLOS throws an error if something goes wrong and you might want to do the same instead of relying on error codes. There is, however, a more indirect problem. Some BOLOS apps silently catch exceptions in the main event loop without erasing app memory. This could lead into a following insidious bug: uint16_t totalSize; uint8_t totalBuf[1000]; void signTx(uint8_t p1, uint8_t p2, uint8_t* data, uint16_t dataSize) { if (p1 == P1_INIT) { totalSize = 0; } uint8_t* ptr = totalBuf[totalSize]; totalSize += dataSize; if (totalSize &gt; SIZEOF(totalBuf)) THROW(ERR); memcpy(ptr, data, dataSize); if (p2 == P2_CONTINUE) { THROW(0x9000); // early exit with success } do_something(); } An attacker might do SignTx(INIT, 100 bytes of data) // OK SignTx(CONTINUE, 100 bytes of data) // OK … SignTx(CONTINUE, 100 bytes of data) // OK SignTx(CONTINUE, 100 bytes of data) // throws … SignTx(CONTINUE, 100 bytes of data) // throws SignTx(CONTINUE, 100 bytes of data) // writes to data[-64..36] The problem here is that the app state is not updated in a “transactional” manner and attacker exploits this. Recommendations: Try to not affect global state before you throw. Many times you can use a scratch memory to assemble result and only then do memmove to write the result. Even better, wipe memory/reboot device on exceptions to destroy any half-updated app states. Too lenient parsing of transactions It might happen that your transaction parsing is too lenient. Importantly, this might cause problems if the transaction serialization spec is ambiguous and different clients might interpret it differently. For example, if a field might be repeated one parser might take the first value while another one a second. In general, lenient tx serialization spec should not happen (and if so, the cryptocurrency has bigger concerns than Ledger wallet). However, even if the network nodes are strict with the serialization checking, you should not slack off on your part. Any ambiguity in parsing adds an attacker a leverage point once it finds some other vulnerability. Recommendation: Be as strict as possible with transaction parsing. Accept only fields which are in normalized form. If possible, avoid repeated fields and accept fields only in a pre-described order. Note: you can even go further and do not parse transaction on the device at all. Instead, just send the data in a custom format and let both the app and host serialize the transaction on their own with the app revealing (and signing) only the serialized hash. This way you can avoid bugs in parsing code and be sure both the host wallet and the app agree perfectly on the content of the transaction. Protect Against “Instruction Change” Attacks Ledger applications live on a secure chip which is very limited in terms of its memory and communication channel. This brings in an interesting problem – the application might not be able to perform all its work in a single request. Instead, the work will need to be spread over multiple requests. Whenever this happens, the application needs to be protected against attacker mixing multiple non-related (or even related) requests. If your application contains at least one instruction which works over multiple APDU exchanges (e.g., having P1_INIT/P1_CONTINUE flag in the standard application “terminology”), you have to protect it from interference. Common attack scenarios: Example: Two multi-APDU instructions Let’s say you have SignTx and SignMessage, both sharing the same global hash variable, both instructions working over multiple APDU exchanges.The attacker might now call SignMessage(INIT) SignTx(INIT) SignMessage(CONTINUE) with data (no finish yet) SignTx(CONTINUE) with data (finish) At this point, the global memory might be in an inconsistent state (for example, the SignTx hash does contain a different hash than it should be). This might lead to an easy attack. Example: Single multi-APDU instruction Even if you have only a single instruction with multiple APDU exchanges, an attacker might gain some leverage. Let’s say you have roughly struct pubkey_ctx { int[10] bip32_path; int bip32_path_len; } struct sign_ctx { hash_ctx hash; // some other data } union { pubkey_ctx pubkey; sign_ctx signTx; } ctx; To overwrite the hash context with an exact chosen value. Example: “Self”-attack on a single multi-APDU instruction You don’t even need two instructions to perform a variation of the attack. Suppose your code goes along these lines void signTx () { if (p1 == P1_INIT) { initialize_half_of_my_state() if (some_bad_input) THROW(error) initialize_rest_of_the_state } else { // do something } } Assuming that you do not reset state on exceptions, this might happen signTx(INIT, valid data) signTx(CONTINUE, valid data) signTx(INIT, data which throws) signTx(CONTINUE, more data) An attacker now managed to reset half of your state (maybe tx length) but not the rest of it (maybe tx hash) which might allow it to attack your code. Obviously, there are many variations of this basic scheme and an utmost care needs to be taken here. The recommendation here is: Do not allow mixing of instructions Within instruction, keep an explicit state machine of what is allowed to happen next) Clear memory on exceptions Use explicit state machines Whenever a host is required to perform certain actions in a specific order, be sure to explicitly track the state and verify that the next step is consistent. Good examples of what might need to be checked If host claims some number of tx inputs/outputs, make sure you receive exactly that amount, not more and not less If the host needs to send multiple transaction inputs and outputs and you have to process inputs before outputs, make sure the host cannot send additional input after it received an output. Check that once you finished an action (signing), the attacker cannot resume with additional data (which might be empty). This is important, because usually signing “closes” some hash contexts (or destroy some other data) and re-running SignTx(CONTINUE, empty data) might, therefore, yield either crash or produce a signature of some different data. In general, after finishing a request you should wipe the context variable If you do not reset UI after sending APDU (for example, because you displayed an address and now you are waiting for another APDU containing tx amount), make sure your button handlers fire just once – a user might press the buttons multiple times. A general recommendation would be to always reset UI with APDU response. Additionally, you can guard your app against itself (and against bad SDK) with tracking whether it should be in IO/UI phase and assert on it in APDU/UI handlers. An (somewhat contrived) example of problematic button handlers void handle_sign_message(...) { ... // validations if (!is_last_apdu) { cx_hash(CX_CONTINUE, ctx-&gt;hash, data); else { memcpy(ctx-&gt;last_part, data); flags *= IO_ASYNCH; display_tx_prompt(); } } unsigned int io_seproxyhal_touch_tx_ok() { // for some reason we modify ctx state here cx_hash(CX_LAST, ctx-&gt;last_part); sign(ctx-&gt;last_part); // now do io_exchange // Warning: this might throw (host might do something weird with USB) // -&gt; user will press the button second time // -&gt; we do another round of cx_hash -&gt; efficiently signing io_exchange(....); // now reset UI ui_idle(); // &lt;-- this line resets button callback } A fully resilient solution would be void display_tx_prompt() { tx_prompt_handled = false; ... } unsigned int io_seproxyhal_touch_tx_ok() { assert(!tx_prompt_handled); tx_prompt_handled = true; ... } unsigned int io_seproxyhal_touch_tx_cancel() { assert(!tx_prompt_handled); tx_prompt_handled = true; ... } But such a solution is needed only if tx_ok or tx_cancel modify context/global variables before calling ui_idle(). (As a side note, if your__ok()/__cancel() handler both 1) do not check whether the memory is cleared, but 2) clear the memory inside the handler; make sure that memclear happens after calling ui_idle()). Note: If not guarded properly, an attacker might try a following line of attack: Send transaction which is not what user wanted User realizes that the transaction is wrong and presses reject Attacker hogs io_exchange (presumably by doing some bad things to USB communication) User tries again a few more times, thinks that the UI is broken and the app hanged. The callbacks are fired again and again but io_exchange still throws At this point in time, a desperate user might click on “confirm” button to unblock the UI. If an attacker can guess this time, she can un-hog USB and receive confirm callback" />
<meta property="og:description" content="Sections in this article Introduction Development practices Code reviews Security audits Developing First App Cryptography Own crypto primitives Avoid blindly signing data Restrict Apps to Coin-Specific BIP32 Prefix Signing/disclosing keys without user approval Private Key Management Be Wary of Untrusted Input Properly protect data you wish to cache on the host computer Do not allow the host to freely manipulate with key-pairs C is your enemy Know your C compiler Use safe macro constructs Buffer overflows/underflows Integer overflows/underflows Data Truncation Stack overflow Optimizations Business logic problems Swallowing errors &amp; half-updated states Too lenient parsing of transactions Protect Against “Instruction Change” Attacks Example: Two multi-APDU instructions Example: Single multi-APDU instruction Example: “Self”-attack on a single multi-APDU instruction Use explicit state machines Introduction Developing applications for Ledger devices (Nano S, X, Blue) is an intricate process. The security of the user funds relies on the fact that the application works in a correct and secure manner and that potential attackers cannot misuse it to extract private data and/or sign requests which are not authorized by the user. The app should guard against such attacks because they have a very low entry point – a Ledger device attached to a compromised host might be a victim of the attacker’s program sending invalid/non-standard requests to the device. This guide is meant to be a summary of all important aspects of Ledger Apps security and it shall be read by developers before developing an app for Ledger. The guide is divided into multiple sections, each taking on a different aspect of security. Development practices Whenever writing a secure Ledger app, the following advice should not be taken lightly. Code reviews We encourage all written code to be peer-reviewed. Importantly, the review should have at least: One reviewer proficient in C and knowing C security weaknesses. One reviewer with “hacker’s mind” (looking at the code from the perspective of an attacker). Security audits We encourage third-party security reviews. Note, however, that solid review takes time and a short review might yield a false sense of security (especially if the reviewing party does not have an extensive knowledge of Ledger code specifics). Developing First App Apart from reading developer documentation at https://ledger.readthedocs.io/en/latest/ we recommend looking at Sia app https://github.com/LedgerHQ/ledger-app-sia which provides a nice starting point for an app, including lots of explanatory comments. A sample of security-wise overly-paranoid app is https://github.com/LedgerHQ/ledger-app-cardano. Cryptography This section presents general concepts about cryptography development, but also guidelines specific to the security model of the Ledger devices. It gives guidelines to: Ensure a potential vulnerability in one application will not cause damages to other apps. Make sure all the operations that manipulate secrets are approved by the user. Restrict the use of these secrets by apps. Own crypto primitives You should never roll your own crypto primitives (including encryption/derivation schemes, hashing functions, HMAC, etc.) Rationale: It is a purpose of BOLOS operating system to perform these in a secure manner. Importantly, writing your own crypto primitives is likely to open you to side-channel attacks or other problems. If your primitive is not supported by BOLOS (e.g., some very new cryptography), consult with Ledger developers the possibility of including it in the OS. Avoid blindly signing data You should never allow signing of any attacker-controlled message unless it has been verified for structural validity. Importantly, you should never sign a message that might be a hash of transaction. Rationale: If you allow an attacker to blindly sign a message, she can easily supply a hash of a valid transaction. Your signature could then be used to send an unauthorized transaction. If you want to sign user-supplied “personal” messages, prefix them with a fixed string (which shouldn’t be a valid transaction prefix). It is also a good practice to include message length in the text to be signed. Ledger-app-eth has a good example in function handleSignPersonalMessage. Note that sometimes cryptocurrencies have a standardized way of signing such personal messages and in that case you should use the approved scheme. Warning: If you allow signing untrusted hashes (while displaying a prompt to the user), be aware that Users do not understand security and could be easily tricked. In fact, they will probably click through your prompt without thinking unless you give them explicit “Warning: this is a very unusual operation. Do not continue unless you know what you are doing” warning. They might not listen even then A compromised host might both change hash on the screen and also data sent to device. This opens the possibility of users signing something they didn’t want to. Restrict Apps to Coin-Specific BIP32 Prefix BIP32 paths on which the app can derive keys must be restricted in your application. The chosen derivation paths must not conflict with existing paths if the use case differs. Warning Ledger will not sign apps whose BIP32 prefixes have not been properly set. Restricting the derivation path can be done by setting the --path property in the app Makefile. For example, if your application derive keys on the hardened path 44’/60’, specify in your Makefile: APP_LOAD_PARAMS += --path &quot;44&#39;/60&#39;&quot; Derivation can also be restricted to a specific curve using the --curve property. Supported curves are secp256k1, prime256r1 and ed25519. Several curves and paths can be configured. For example, if your app must derive keys on paths 44’/535348’, 13’ and 17’, on curves Ed25519 and prime256r1, the Makefile should contain: APP_LOAD_PARAMS=--curve ed25519 --curve prime256r1 --path &quot;44&#39;/535348&#39;&quot; --path &quot;13&#39;&quot; --path &quot;17&#39;&quot; Rationale: Setting prefixes is crucial, as it limites the amount of damages an attacker can do if he manages to compromise an application. If a vulnerability is exploited on a poorly written of backdoored application, an attacker should not be able to exploit it to extract private keys from other apps, such as Bitcoin or Ethereum keys. Warning If your application derives keys on the hardened path 44&#39;/60&#39; then the chainID parameter must be different from 0 or 1. This is necessary to avoid replaying transactions broadcoast on Ethereum-like chains on Ethereum. As a general recommendation, and to ensure a good level of privacy for the end user, we recommend to always use the correct coin type in the derivation path as defined in slip44 (&lt;https://github.com/satoshilabs/slips/blob/master/slip-0044.md&gt;) Signing/disclosing keys without user approval Warning You must always require user approval for signing transactions/messages. Rationale: If you do not require user consent for signing important data, an attacker can use your device as a signing black box and sign whatever it wants. Note You might also consider approvals for extracting public keys, as some users might want extended privacy. 1. They might not want to reveal their *root/account* public key, only address keys 2. They might not want to reveal address public key until it is required. (Some cryptocurrencies use addresses that are hash of public keys. It is therefore enough to send the address to the host). Note that there is a trade-off between privacy and usability here. If you want privacy, it would require a user interaction every time they want to use Ledger device, as opposed to only interaction while signing transactions. The behaviour could also be manually set in the application options. Private Key Management You should minimize the code that works with private (ECDSA, RSA, etc.) or secret (HMAC, AES, etc.) keys. Importantly, you should always clear the memory after you use these keys. That includes key data and key objects. Leaving parts of private or secret keys lying around in memory is not a security issue on its own because there is no easy way to extract the content of RAM on the chip. If a key is left in RAM by an app, another app will not be able to access it. However, if the key has not been properly erased, a security issue could lead to the leak of this key, even if it is not used anymore. An attacker able to read arbitrary memory from the app, or execute arbitrary code, will be able to read the content of the stack segment, hence the parts of the key which have not been erased. A common (and wrong) way of doing this: uint8_t privateKeyData[64]; cx_ecfp_private_key_t privateKey; os_perso_derive_node_bip32( tmpCtx.transactionContext.curve, tmpCtx.transactionContext.bip32Path, tmpCtx.transactionContext.pathLength, privateKeyData, NULL); cx_ecfp_init_private_key(tmpCtx.transactionContext.curve, privateKeyData, 32, &amp;privateKey); explicit_bzero(privateKeyData, sizeof(privateKeyData)); // (later, after privateKey is not needed) explicit_bzero(&amp;privateKey, sizeof(privateKey)); In the happy path, the previous code will correctly clean the memory once the private key is initialized. Note, however, that this code fails to protect private key in case some system call throws (for example cx_ecfp_init_private_key). Correct code should wrap the clearing in BEGIN_TRY { TRY { ... } FINALLY { explicit_bzero() } END_TRY;. Applications where such issues were fixed include the ARK app and the Solana app. Be Wary of Untrusted Input Some cryptocurrencies do not have explicit fee encoded in the transaction. In such cases, the app cannot rely on fee value sent from the host. Instead, it should receive previous UTxOs and check their output amounts. Note that this usually needs to be done in a separate step due to memory constraints. Check with BTC/Cardano app design for this. Properly protect data you wish to cache on the host computer Sometimes your app needs to compute over more data than it can fit inside memory. Taking an example from the previous section, it might not be easy to store all UTxOs in memory of Ledger. As such, you might break computation into multiple steps and, for example, verify each UTxO separately and let the host computer to cache a “certified summary”. If you do this, be aware that If the information you want the host to cache is public, you still need to attach a signature to it so that the host cannot send some other value later. This could be done with standard HMAC digest. We would recommend using a temporary (per session) key for this –having a per-session HMAC allows you to truncate the digest size (e.g., you don’t need to have HMAC which withstands years of brute-force attack. Instead, you can balance the digest size against some reasonable upper bound on how long the session lives (e.g., one month should be enough)). If the information is not public, you need to both encrypt and provide a signature. Notably, it is not enough to “scramble” the data by XORing with a random key as this would still allow the attacker to tamper with the values. (Or even break the scrambling if you re-use the same key). Instead: Encrypt the information with a sufficiently strong cipher Provide a digest to avoid tampering with the value Do not allow the host to freely manipulate with key-pairs Some cryptocurrencies (notably Monero) need to perform an extensive calculation with (public, private) key-pair spread over multiple APDU exchanges. If you need to do the same, do not allow the attacker to step out of the protocol. Notably, allowing the attacker to freely perform key manipulation (e.g., group multiplications, exponentiations, etc.) could undermine your app security even if the private key never leaves the device. In general, keep an explicit protocol state machine during the computation. Also, consult with cryptography experts to check for implications if you misstep from the protocol. C is your enemy Know your C compiler Ledger apps are written in C. Unlike typical embedded project, the goal here is to write for a single platform with a single compiler. The current supported compiler is clang, and it supports newest language features (up to C11). This is useful for both development and security. You should really learn about the new features and use them extensively as they might help you writing more secure code. A random collection of useful features: intermingled declarations and code, support of _Generic, _Static_assert, __builtin_types_compatible_p, __typeof (very useful for safer versions of macros), etc. Use safe macro constructs C is a minefield of problems related to pointers. You can alleviate some of the problems with good macros. However, beware of when they can fail. For example, take the following code: #define ARRAY_LEN(a) sizeof(a) / sizeof(a[0]) Apart from the “obvious” problem of ARRAY_LEN macro being written without external parenthesis, making code such as (uint8_t) ARRAY_LEN(x) compile to what is understood by the compiler as (uint8_t) sizeof(x) / sizeof(x[0]) there is an important problem with this macro. If used in the function like this void fn(int x[10]) { int len = ARRAY_LEN(x) } The result is unexpectedly len=1. The reason is that int x[10] in the function header is silently converted into int* x and the length is therefore sizeof(ptr) / sizeof(int) which is indeed 1 on the platform. You can read more about the problem and how to define a safe version in http://zubplot.blogspot.com/2015/01/gcc-is-wonderful-better-arraysize-macro.html which explains a patch to the Linux kernel to improve safety of its ARRAY_SIZE macro. Note that similar problems exist, if x is a pointer, with: memset(x, 0, sizeof(x)) In general, if writing macros, try to write them in a way that they will fail if they get a pointer instead of struct/array. Buffer overflows/underflows Buffer overflows and underflows are perhaps the biggest source of security vulnerabilities in C code. The following example shows a buffer overflow in (a past version) of one Ledger app. #define MAX_RAW_TX 200 ... struct tmpCtx { ... uint8_t rawTx[MAX_RAW_TX]; } transactionContext_t; const uint8_t PREFIX[] = {0x00, 0x01, 0x02 ... } // coin-specific signing prefix void handleSign(uint8_t p1, uint8_t p2, uint8_t *workBuffer, uint16_t dataLength, volatile unsigned int *flags, volatile unsigned int *tx) { ... // (no dataLength validation, we can get up to 255 from APDU) // Note: we can pass this line with dataLength &gt; 200 if (parseTx(workBuffer, dataLength, &amp;txContent) != USTREAM_FINISHED) { THROW(0x6A80); } ... memmove(tmpCtx.rawTx, PREFIX, sizeof(PREFIX)); // Here is the vulnerability. There should be a check of // if (!(dataLength + sizeof(SIGN_PREFIX) &lt; MAX_RAW_TX)) THROW(...) memmove(tmpCtx.transactionContext.rawTx + sizeof(SIGN_PREFIX), workBuffer, dataLength); } In general, there is only a single remedy for buffer overflows -always check for available buffer space before writing to memory. The best is to not rely on some specific buffer size but instead rely on sizeof operator. If using sizeof, however, be very careful - if you ever pass a buffer to a function, you are losing its size! uint8_t a[100]; main() { sizeof(a); // 100 f(a); g(a); } void f(uint8_t* x) { sizeof(x); // 4 } void g(uint8_t oops[100]) { sizeof(oops); // 4 } For the extra safery, consider using a SIZEOF macro defined similarly to https://github.com/LedgerHQ/ledger-app-cardano/blob/f578c903c19288495a359a2bc909b39c33ee69ca/src/utils.h#L27 Be also wary of constructs like memset(displayAddress, 0, sizeof(fullAddress)); memmove((void *)displayAddress, tmpCtx.address, 5); memmove((void *)(displayAddress + 5), &quot;...&quot;, 3); memmove((void *)(displayAddress + 8), tmpCtx.address + addressLength - 4, 4); There are several problematic aspects of such code. Apart from truncating important values (see next sections), this code makes a lot of assumptions. For example, if addressLength &lt; 4 (maybe some previous function returns addressLength=0 instead of an error) we get buffer underflow and copy up to 4 bytes of other memory and display it to the user. Or a programmer decides to shorten definition of fullAddress below 13 and we would overwrite memory after the buffer. Finally, this code uses explicit indexes (e.g., 5, 8=5+3). A better trick would be to have a safe helper macro: #define APPEND(ptr, end, from, len) \ do { \ if (ptr + len &gt;= end || len &lt; 0) THROW(); // not enough space \ memcpy(ptr, from, len); \ ptr += len; \ } while(0) char* ptr_begin = displayAddress; char* ptr_end = displayAddress + sizeof(displayAddress); // points behind buffer APPEND(ptr_begin, ptr_end, tmpCtx.address, 5); // we should also assert addressLength&gt;5 APPEND(ptr_begin, ptr_end, &quot;...&quot;, 3); // Note, we still have explicit size here APPEND(ptr_begin, ptr_end, tmpCtx.address - 4, 4); // Note: another assert Finally, you can use SPRINTF macro from sdk/include/os_io_seproxyhal.h but be aware that the definition is #define SPRINTF(strbuf, ...) snprintf(strbuf, sizeof(strbuf), __VA_ARGS__) so the above warning about passing pointers instead of arrays applies to it. Integer overflows/underflows Integer overflows go hand in hand with buffer overflows. In fact, they can cause serious buffer overflows. Consider following code where a numeric underflow causes buffer overflow of 64kB! void handleSign(uint8_t p1, uint8_t p2, uint8_t *workBuffer, uint16_t dataLength, volatile unsigned int *flags, volatile unsigned int *tx) { uint32_t i; // here we don&#39;t check if dataLength &gt; 0 so we might be reading behind the buffer tmpCtx.transactionContext.pathLength = workBuffer[0]; if ((tmpCtx.transactionContext.pathLength &lt; 0x01) || (tmpCtx.transactionContext.pathLength &gt; MAX_BIP32_PATH)) { PRINTF(&quot;Invalid path\n&quot;); THROW(0x6a80); } workBuffer++; dataLength--; for (i = 0; i &lt; tmpCtx.transactionContext.pathLength; i++) { tmpCtx.transactionContext.bip32Path[i] = (workBuffer[0] &lt;&lt; 24) | (workBuffer[1] &lt;&lt; 16) | (workBuffer[2] &lt;&lt; 8) | (workBuffer[3]); workBuffer += 4; // here we again blindly assume dataLength &gt;= 4 dataLength -= 4; } initTxContext(&amp;txProcessingCtx, &amp;sha256, &amp;dataSha256, &amp;txContent, N_storage.dataAllowed); // if we sent APDU with dataLength=0 at the beginning, we would end up with dataLength ~ 64kB here txResult = parseTx(&amp;txProcessingCtx, workBuffer, dataLength); ... } As a general rule, be very careful about variables which might overflow or underflow. If possible, use bigger types that can accommodate the arithmetic operations you need to perform. For buffer sizes, prefer unsigned types – that way, you can easily check both overflow and underflow in one go, i.e. void f(uint8_t* buf, size_t bufSize) { // size_t is unsigned if (bufSize &lt; REASONABLE_SIZE) THROW(); // guards both against underflow and overflow! } Data Truncation Speaking of safely formatting data, be wary of truncated values. Importantly, make sure you do not truncate any important data when displaying on the Ledger screen. Example 1: Truncating tx hash from “f6954eb23ecd1d64c782e6d6c32fad2876003ae92986606585ae7187470d5e04” to “f695…5e04” might look nice for the users but this effectively reduces the security of hash and an attacker can now easily try to create a hash collision. Instead, prefer scrolling/paging of long such important values. Example 2: Raise errors instead of truncation int tmp[10]; // max 10 digits, right? uint32_t amount = 1987654321 SPRINTF(tmp, &quot;%d&quot;, amount) // at least we won&#39;t get buffer overflow here ... display(tmp) // but we display an empty screen! // but it could be worse // with bad custom formatting function we could get format_amount(tmp, SIZEOF(tmp), amount) // &quot;198765432&quot; or &quot;987654321&quot; Stack overflow You application has only a limited size (about ~700B) of stack. That is one of the reasons why stack cookies are not supported yet on the platform. Given the memory constraints, BOLOS OS does not have memory mapping which would protect from stack overflow errors. As a result, it is very easy to consume more stack space and overwrite the end of your data. Recommendation: Enable DEFINES += HAVE_BOLOS_APP_STACK_CANARY in your Makefile. This will help you detect stack overflows during app development. If overflow is detected, the app will reboot the device. Note that the overflow check happens only on the next I/O. This means that the protection is not instant and an attacker might avoid the canary check: this option is not a security feature, and has been added to analyze the stack usage during testing process. Optimizations Do not clear sensitive data with for-loops or other techniques. Do not user memset or bzero to clear sensitive data: it could be optimized and removed by the compiler. Recommendation: Use explicit_bzero which guarantees that the compiler will not remove the erasure. (See https://www.owasp.org/index.php/Insecure\_Compiler\_Optimization for an example of how things could go wrong.) Business logic problems Swallowing errors &amp; half-updated states It goes without saying that you should check return value of functions for any errors. Fortunately, BOLOS throws an error if something goes wrong and you might want to do the same instead of relying on error codes. There is, however, a more indirect problem. Some BOLOS apps silently catch exceptions in the main event loop without erasing app memory. This could lead into a following insidious bug: uint16_t totalSize; uint8_t totalBuf[1000]; void signTx(uint8_t p1, uint8_t p2, uint8_t* data, uint16_t dataSize) { if (p1 == P1_INIT) { totalSize = 0; } uint8_t* ptr = totalBuf[totalSize]; totalSize += dataSize; if (totalSize &gt; SIZEOF(totalBuf)) THROW(ERR); memcpy(ptr, data, dataSize); if (p2 == P2_CONTINUE) { THROW(0x9000); // early exit with success } do_something(); } An attacker might do SignTx(INIT, 100 bytes of data) // OK SignTx(CONTINUE, 100 bytes of data) // OK … SignTx(CONTINUE, 100 bytes of data) // OK SignTx(CONTINUE, 100 bytes of data) // throws … SignTx(CONTINUE, 100 bytes of data) // throws SignTx(CONTINUE, 100 bytes of data) // writes to data[-64..36] The problem here is that the app state is not updated in a “transactional” manner and attacker exploits this. Recommendations: Try to not affect global state before you throw. Many times you can use a scratch memory to assemble result and only then do memmove to write the result. Even better, wipe memory/reboot device on exceptions to destroy any half-updated app states. Too lenient parsing of transactions It might happen that your transaction parsing is too lenient. Importantly, this might cause problems if the transaction serialization spec is ambiguous and different clients might interpret it differently. For example, if a field might be repeated one parser might take the first value while another one a second. In general, lenient tx serialization spec should not happen (and if so, the cryptocurrency has bigger concerns than Ledger wallet). However, even if the network nodes are strict with the serialization checking, you should not slack off on your part. Any ambiguity in parsing adds an attacker a leverage point once it finds some other vulnerability. Recommendation: Be as strict as possible with transaction parsing. Accept only fields which are in normalized form. If possible, avoid repeated fields and accept fields only in a pre-described order. Note: you can even go further and do not parse transaction on the device at all. Instead, just send the data in a custom format and let both the app and host serialize the transaction on their own with the app revealing (and signing) only the serialized hash. This way you can avoid bugs in parsing code and be sure both the host wallet and the app agree perfectly on the content of the transaction. Protect Against “Instruction Change” Attacks Ledger applications live on a secure chip which is very limited in terms of its memory and communication channel. This brings in an interesting problem – the application might not be able to perform all its work in a single request. Instead, the work will need to be spread over multiple requests. Whenever this happens, the application needs to be protected against attacker mixing multiple non-related (or even related) requests. If your application contains at least one instruction which works over multiple APDU exchanges (e.g., having P1_INIT/P1_CONTINUE flag in the standard application “terminology”), you have to protect it from interference. Common attack scenarios: Example: Two multi-APDU instructions Let’s say you have SignTx and SignMessage, both sharing the same global hash variable, both instructions working over multiple APDU exchanges.The attacker might now call SignMessage(INIT) SignTx(INIT) SignMessage(CONTINUE) with data (no finish yet) SignTx(CONTINUE) with data (finish) At this point, the global memory might be in an inconsistent state (for example, the SignTx hash does contain a different hash than it should be). This might lead to an easy attack. Example: Single multi-APDU instruction Even if you have only a single instruction with multiple APDU exchanges, an attacker might gain some leverage. Let’s say you have roughly struct pubkey_ctx { int[10] bip32_path; int bip32_path_len; } struct sign_ctx { hash_ctx hash; // some other data } union { pubkey_ctx pubkey; sign_ctx signTx; } ctx; To overwrite the hash context with an exact chosen value. Example: “Self”-attack on a single multi-APDU instruction You don’t even need two instructions to perform a variation of the attack. Suppose your code goes along these lines void signTx () { if (p1 == P1_INIT) { initialize_half_of_my_state() if (some_bad_input) THROW(error) initialize_rest_of_the_state } else { // do something } } Assuming that you do not reset state on exceptions, this might happen signTx(INIT, valid data) signTx(CONTINUE, valid data) signTx(INIT, data which throws) signTx(CONTINUE, more data) An attacker now managed to reset half of your state (maybe tx length) but not the rest of it (maybe tx hash) which might allow it to attack your code. Obviously, there are many variations of this basic scheme and an utmost care needs to be taken here. The recommendation here is: Do not allow mixing of instructions Within instruction, keep an explicit state machine of what is allowed to happen next) Clear memory on exceptions Use explicit state machines Whenever a host is required to perform certain actions in a specific order, be sure to explicitly track the state and verify that the next step is consistent. Good examples of what might need to be checked If host claims some number of tx inputs/outputs, make sure you receive exactly that amount, not more and not less If the host needs to send multiple transaction inputs and outputs and you have to process inputs before outputs, make sure the host cannot send additional input after it received an output. Check that once you finished an action (signing), the attacker cannot resume with additional data (which might be empty). This is important, because usually signing “closes” some hash contexts (or destroy some other data) and re-running SignTx(CONTINUE, empty data) might, therefore, yield either crash or produce a signature of some different data. In general, after finishing a request you should wipe the context variable If you do not reset UI after sending APDU (for example, because you displayed an address and now you are waiting for another APDU containing tx amount), make sure your button handlers fire just once – a user might press the buttons multiple times. A general recommendation would be to always reset UI with APDU response. Additionally, you can guard your app against itself (and against bad SDK) with tracking whether it should be in IO/UI phase and assert on it in APDU/UI handlers. An (somewhat contrived) example of problematic button handlers void handle_sign_message(...) { ... // validations if (!is_last_apdu) { cx_hash(CX_CONTINUE, ctx-&gt;hash, data); else { memcpy(ctx-&gt;last_part, data); flags *= IO_ASYNCH; display_tx_prompt(); } } unsigned int io_seproxyhal_touch_tx_ok() { // for some reason we modify ctx state here cx_hash(CX_LAST, ctx-&gt;last_part); sign(ctx-&gt;last_part); // now do io_exchange // Warning: this might throw (host might do something weird with USB) // -&gt; user will press the button second time // -&gt; we do another round of cx_hash -&gt; efficiently signing io_exchange(....); // now reset UI ui_idle(); // &lt;-- this line resets button callback } A fully resilient solution would be void display_tx_prompt() { tx_prompt_handled = false; ... } unsigned int io_seproxyhal_touch_tx_ok() { assert(!tx_prompt_handled); tx_prompt_handled = true; ... } unsigned int io_seproxyhal_touch_tx_cancel() { assert(!tx_prompt_handled); tx_prompt_handled = true; ... } But such a solution is needed only if tx_ok or tx_cancel modify context/global variables before calling ui_idle(). (As a side note, if your__ok()/__cancel() handler both 1) do not check whether the memory is cleared, but 2) clear the memory inside the handler; make sure that memclear happens after calling ui_idle()). Note: If not guarded properly, an attacker might try a following line of attack: Send transaction which is not what user wanted User realizes that the transaction is wrong and presses reject Attacker hogs io_exchange (presumably by doing some bad things to USB communication) User tries again a few more times, thinks that the UI is broken and the app hanged. The callbacks are fired again and again but io_exchange still throws At this point in time, a desperate user might click on “confirm” button to unblock the UI. If an attacker can guess this time, she can un-hog USB and receive confirm callback" />
<link rel="canonical" href="http://localhost:4000/docs/NA/a_security_guidelines/" />
<meta property="og:url" content="http://localhost:4000/docs/NA/a_security_guidelines/" />
<meta property="og:site_name" content="Ledger Developer pages" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-04-22T15:38:24+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Developing Secure Ledger Apps" />
<script type="application/ld+json">
{"datePublished":"2021-04-22T15:38:24+02:00","description":"Sections in this article Introduction Development practices Code reviews Security audits Developing First App Cryptography Own crypto primitives Avoid blindly signing data Restrict Apps to Coin-Specific BIP32 Prefix Signing/disclosing keys without user approval Private Key Management Be Wary of Untrusted Input Properly protect data you wish to cache on the host computer Do not allow the host to freely manipulate with key-pairs C is your enemy Know your C compiler Use safe macro constructs Buffer overflows/underflows Integer overflows/underflows Data Truncation Stack overflow Optimizations Business logic problems Swallowing errors &amp; half-updated states Too lenient parsing of transactions Protect Against “Instruction Change” Attacks Example: Two multi-APDU instructions Example: Single multi-APDU instruction Example: “Self”-attack on a single multi-APDU instruction Use explicit state machines Introduction Developing applications for Ledger devices (Nano S, X, Blue) is an intricate process. The security of the user funds relies on the fact that the application works in a correct and secure manner and that potential attackers cannot misuse it to extract private data and/or sign requests which are not authorized by the user. The app should guard against such attacks because they have a very low entry point – a Ledger device attached to a compromised host might be a victim of the attacker’s program sending invalid/non-standard requests to the device. This guide is meant to be a summary of all important aspects of Ledger Apps security and it shall be read by developers before developing an app for Ledger. The guide is divided into multiple sections, each taking on a different aspect of security. Development practices Whenever writing a secure Ledger app, the following advice should not be taken lightly. Code reviews We encourage all written code to be peer-reviewed. Importantly, the review should have at least: One reviewer proficient in C and knowing C security weaknesses. One reviewer with “hacker’s mind” (looking at the code from the perspective of an attacker). Security audits We encourage third-party security reviews. Note, however, that solid review takes time and a short review might yield a false sense of security (especially if the reviewing party does not have an extensive knowledge of Ledger code specifics). Developing First App Apart from reading developer documentation at https://ledger.readthedocs.io/en/latest/ we recommend looking at Sia app https://github.com/LedgerHQ/ledger-app-sia which provides a nice starting point for an app, including lots of explanatory comments. A sample of security-wise overly-paranoid app is https://github.com/LedgerHQ/ledger-app-cardano. Cryptography This section presents general concepts about cryptography development, but also guidelines specific to the security model of the Ledger devices. It gives guidelines to: Ensure a potential vulnerability in one application will not cause damages to other apps. Make sure all the operations that manipulate secrets are approved by the user. Restrict the use of these secrets by apps. Own crypto primitives You should never roll your own crypto primitives (including encryption/derivation schemes, hashing functions, HMAC, etc.) Rationale: It is a purpose of BOLOS operating system to perform these in a secure manner. Importantly, writing your own crypto primitives is likely to open you to side-channel attacks or other problems. If your primitive is not supported by BOLOS (e.g., some very new cryptography), consult with Ledger developers the possibility of including it in the OS. Avoid blindly signing data You should never allow signing of any attacker-controlled message unless it has been verified for structural validity. Importantly, you should never sign a message that might be a hash of transaction. Rationale: If you allow an attacker to blindly sign a message, she can easily supply a hash of a valid transaction. Your signature could then be used to send an unauthorized transaction. If you want to sign user-supplied “personal” messages, prefix them with a fixed string (which shouldn’t be a valid transaction prefix). It is also a good practice to include message length in the text to be signed. Ledger-app-eth has a good example in function handleSignPersonalMessage. Note that sometimes cryptocurrencies have a standardized way of signing such personal messages and in that case you should use the approved scheme. Warning: If you allow signing untrusted hashes (while displaying a prompt to the user), be aware that Users do not understand security and could be easily tricked. In fact, they will probably click through your prompt without thinking unless you give them explicit “Warning: this is a very unusual operation. Do not continue unless you know what you are doing” warning. They might not listen even then A compromised host might both change hash on the screen and also data sent to device. This opens the possibility of users signing something they didn’t want to. Restrict Apps to Coin-Specific BIP32 Prefix BIP32 paths on which the app can derive keys must be restricted in your application. The chosen derivation paths must not conflict with existing paths if the use case differs. Warning Ledger will not sign apps whose BIP32 prefixes have not been properly set. Restricting the derivation path can be done by setting the --path property in the app Makefile. For example, if your application derive keys on the hardened path 44’/60’, specify in your Makefile: APP_LOAD_PARAMS += --path &quot;44&#39;/60&#39;&quot; Derivation can also be restricted to a specific curve using the --curve property. Supported curves are secp256k1, prime256r1 and ed25519. Several curves and paths can be configured. For example, if your app must derive keys on paths 44’/535348’, 13’ and 17’, on curves Ed25519 and prime256r1, the Makefile should contain: APP_LOAD_PARAMS=--curve ed25519 --curve prime256r1 --path &quot;44&#39;/535348&#39;&quot; --path &quot;13&#39;&quot; --path &quot;17&#39;&quot; Rationale: Setting prefixes is crucial, as it limites the amount of damages an attacker can do if he manages to compromise an application. If a vulnerability is exploited on a poorly written of backdoored application, an attacker should not be able to exploit it to extract private keys from other apps, such as Bitcoin or Ethereum keys. Warning If your application derives keys on the hardened path 44&#39;/60&#39; then the chainID parameter must be different from 0 or 1. This is necessary to avoid replaying transactions broadcoast on Ethereum-like chains on Ethereum. As a general recommendation, and to ensure a good level of privacy for the end user, we recommend to always use the correct coin type in the derivation path as defined in slip44 (&lt;https://github.com/satoshilabs/slips/blob/master/slip-0044.md&gt;) Signing/disclosing keys without user approval Warning You must always require user approval for signing transactions/messages. Rationale: If you do not require user consent for signing important data, an attacker can use your device as a signing black box and sign whatever it wants. Note You might also consider approvals for extracting public keys, as some users might want extended privacy. 1. They might not want to reveal their *root/account* public key, only address keys 2. They might not want to reveal address public key until it is required. (Some cryptocurrencies use addresses that are hash of public keys. It is therefore enough to send the address to the host). Note that there is a trade-off between privacy and usability here. If you want privacy, it would require a user interaction every time they want to use Ledger device, as opposed to only interaction while signing transactions. The behaviour could also be manually set in the application options. Private Key Management You should minimize the code that works with private (ECDSA, RSA, etc.) or secret (HMAC, AES, etc.) keys. Importantly, you should always clear the memory after you use these keys. That includes key data and key objects. Leaving parts of private or secret keys lying around in memory is not a security issue on its own because there is no easy way to extract the content of RAM on the chip. If a key is left in RAM by an app, another app will not be able to access it. However, if the key has not been properly erased, a security issue could lead to the leak of this key, even if it is not used anymore. An attacker able to read arbitrary memory from the app, or execute arbitrary code, will be able to read the content of the stack segment, hence the parts of the key which have not been erased. A common (and wrong) way of doing this: uint8_t privateKeyData[64]; cx_ecfp_private_key_t privateKey; os_perso_derive_node_bip32( tmpCtx.transactionContext.curve, tmpCtx.transactionContext.bip32Path, tmpCtx.transactionContext.pathLength, privateKeyData, NULL); cx_ecfp_init_private_key(tmpCtx.transactionContext.curve, privateKeyData, 32, &amp;privateKey); explicit_bzero(privateKeyData, sizeof(privateKeyData)); // (later, after privateKey is not needed) explicit_bzero(&amp;privateKey, sizeof(privateKey)); In the happy path, the previous code will correctly clean the memory once the private key is initialized. Note, however, that this code fails to protect private key in case some system call throws (for example cx_ecfp_init_private_key). Correct code should wrap the clearing in BEGIN_TRY { TRY { ... } FINALLY { explicit_bzero() } END_TRY;. Applications where such issues were fixed include the ARK app and the Solana app. Be Wary of Untrusted Input Some cryptocurrencies do not have explicit fee encoded in the transaction. In such cases, the app cannot rely on fee value sent from the host. Instead, it should receive previous UTxOs and check their output amounts. Note that this usually needs to be done in a separate step due to memory constraints. Check with BTC/Cardano app design for this. Properly protect data you wish to cache on the host computer Sometimes your app needs to compute over more data than it can fit inside memory. Taking an example from the previous section, it might not be easy to store all UTxOs in memory of Ledger. As such, you might break computation into multiple steps and, for example, verify each UTxO separately and let the host computer to cache a “certified summary”. If you do this, be aware that If the information you want the host to cache is public, you still need to attach a signature to it so that the host cannot send some other value later. This could be done with standard HMAC digest. We would recommend using a temporary (per session) key for this –having a per-session HMAC allows you to truncate the digest size (e.g., you don’t need to have HMAC which withstands years of brute-force attack. Instead, you can balance the digest size against some reasonable upper bound on how long the session lives (e.g., one month should be enough)). If the information is not public, you need to both encrypt and provide a signature. Notably, it is not enough to “scramble” the data by XORing with a random key as this would still allow the attacker to tamper with the values. (Or even break the scrambling if you re-use the same key). Instead: Encrypt the information with a sufficiently strong cipher Provide a digest to avoid tampering with the value Do not allow the host to freely manipulate with key-pairs Some cryptocurrencies (notably Monero) need to perform an extensive calculation with (public, private) key-pair spread over multiple APDU exchanges. If you need to do the same, do not allow the attacker to step out of the protocol. Notably, allowing the attacker to freely perform key manipulation (e.g., group multiplications, exponentiations, etc.) could undermine your app security even if the private key never leaves the device. In general, keep an explicit protocol state machine during the computation. Also, consult with cryptography experts to check for implications if you misstep from the protocol. C is your enemy Know your C compiler Ledger apps are written in C. Unlike typical embedded project, the goal here is to write for a single platform with a single compiler. The current supported compiler is clang, and it supports newest language features (up to C11). This is useful for both development and security. You should really learn about the new features and use them extensively as they might help you writing more secure code. A random collection of useful features: intermingled declarations and code, support of _Generic, _Static_assert, __builtin_types_compatible_p, __typeof (very useful for safer versions of macros), etc. Use safe macro constructs C is a minefield of problems related to pointers. You can alleviate some of the problems with good macros. However, beware of when they can fail. For example, take the following code: #define ARRAY_LEN(a) sizeof(a) / sizeof(a[0]) Apart from the “obvious” problem of ARRAY_LEN macro being written without external parenthesis, making code such as (uint8_t) ARRAY_LEN(x) compile to what is understood by the compiler as (uint8_t) sizeof(x) / sizeof(x[0]) there is an important problem with this macro. If used in the function like this void fn(int x[10]) { int len = ARRAY_LEN(x) } The result is unexpectedly len=1. The reason is that int x[10] in the function header is silently converted into int* x and the length is therefore sizeof(ptr) / sizeof(int) which is indeed 1 on the platform. You can read more about the problem and how to define a safe version in http://zubplot.blogspot.com/2015/01/gcc-is-wonderful-better-arraysize-macro.html which explains a patch to the Linux kernel to improve safety of its ARRAY_SIZE macro. Note that similar problems exist, if x is a pointer, with: memset(x, 0, sizeof(x)) In general, if writing macros, try to write them in a way that they will fail if they get a pointer instead of struct/array. Buffer overflows/underflows Buffer overflows and underflows are perhaps the biggest source of security vulnerabilities in C code. The following example shows a buffer overflow in (a past version) of one Ledger app. #define MAX_RAW_TX 200 ... struct tmpCtx { ... uint8_t rawTx[MAX_RAW_TX]; } transactionContext_t; const uint8_t PREFIX[] = {0x00, 0x01, 0x02 ... } // coin-specific signing prefix void handleSign(uint8_t p1, uint8_t p2, uint8_t *workBuffer, uint16_t dataLength, volatile unsigned int *flags, volatile unsigned int *tx) { ... // (no dataLength validation, we can get up to 255 from APDU) // Note: we can pass this line with dataLength &gt; 200 if (parseTx(workBuffer, dataLength, &amp;txContent) != USTREAM_FINISHED) { THROW(0x6A80); } ... memmove(tmpCtx.rawTx, PREFIX, sizeof(PREFIX)); // Here is the vulnerability. There should be a check of // if (!(dataLength + sizeof(SIGN_PREFIX) &lt; MAX_RAW_TX)) THROW(...) memmove(tmpCtx.transactionContext.rawTx + sizeof(SIGN_PREFIX), workBuffer, dataLength); } In general, there is only a single remedy for buffer overflows -always check for available buffer space before writing to memory. The best is to not rely on some specific buffer size but instead rely on sizeof operator. If using sizeof, however, be very careful - if you ever pass a buffer to a function, you are losing its size! uint8_t a[100]; main() { sizeof(a); // 100 f(a); g(a); } void f(uint8_t* x) { sizeof(x); // 4 } void g(uint8_t oops[100]) { sizeof(oops); // 4 } For the extra safery, consider using a SIZEOF macro defined similarly to https://github.com/LedgerHQ/ledger-app-cardano/blob/f578c903c19288495a359a2bc909b39c33ee69ca/src/utils.h#L27 Be also wary of constructs like memset(displayAddress, 0, sizeof(fullAddress)); memmove((void *)displayAddress, tmpCtx.address, 5); memmove((void *)(displayAddress + 5), &quot;...&quot;, 3); memmove((void *)(displayAddress + 8), tmpCtx.address + addressLength - 4, 4); There are several problematic aspects of such code. Apart from truncating important values (see next sections), this code makes a lot of assumptions. For example, if addressLength &lt; 4 (maybe some previous function returns addressLength=0 instead of an error) we get buffer underflow and copy up to 4 bytes of other memory and display it to the user. Or a programmer decides to shorten definition of fullAddress below 13 and we would overwrite memory after the buffer. Finally, this code uses explicit indexes (e.g., 5, 8=5+3). A better trick would be to have a safe helper macro: #define APPEND(ptr, end, from, len) \\ do { \\ if (ptr + len &gt;= end || len &lt; 0) THROW(); // not enough space \\ memcpy(ptr, from, len); \\ ptr += len; \\ } while(0) char* ptr_begin = displayAddress; char* ptr_end = displayAddress + sizeof(displayAddress); // points behind buffer APPEND(ptr_begin, ptr_end, tmpCtx.address, 5); // we should also assert addressLength&gt;5 APPEND(ptr_begin, ptr_end, &quot;...&quot;, 3); // Note, we still have explicit size here APPEND(ptr_begin, ptr_end, tmpCtx.address - 4, 4); // Note: another assert Finally, you can use SPRINTF macro from sdk/include/os_io_seproxyhal.h but be aware that the definition is #define SPRINTF(strbuf, ...) snprintf(strbuf, sizeof(strbuf), __VA_ARGS__) so the above warning about passing pointers instead of arrays applies to it. Integer overflows/underflows Integer overflows go hand in hand with buffer overflows. In fact, they can cause serious buffer overflows. Consider following code where a numeric underflow causes buffer overflow of 64kB! void handleSign(uint8_t p1, uint8_t p2, uint8_t *workBuffer, uint16_t dataLength, volatile unsigned int *flags, volatile unsigned int *tx) { uint32_t i; // here we don&#39;t check if dataLength &gt; 0 so we might be reading behind the buffer tmpCtx.transactionContext.pathLength = workBuffer[0]; if ((tmpCtx.transactionContext.pathLength &lt; 0x01) || (tmpCtx.transactionContext.pathLength &gt; MAX_BIP32_PATH)) { PRINTF(&quot;Invalid path\\n&quot;); THROW(0x6a80); } workBuffer++; dataLength--; for (i = 0; i &lt; tmpCtx.transactionContext.pathLength; i++) { tmpCtx.transactionContext.bip32Path[i] = (workBuffer[0] &lt;&lt; 24) | (workBuffer[1] &lt;&lt; 16) | (workBuffer[2] &lt;&lt; 8) | (workBuffer[3]); workBuffer += 4; // here we again blindly assume dataLength &gt;= 4 dataLength -= 4; } initTxContext(&amp;txProcessingCtx, &amp;sha256, &amp;dataSha256, &amp;txContent, N_storage.dataAllowed); // if we sent APDU with dataLength=0 at the beginning, we would end up with dataLength ~ 64kB here txResult = parseTx(&amp;txProcessingCtx, workBuffer, dataLength); ... } As a general rule, be very careful about variables which might overflow or underflow. If possible, use bigger types that can accommodate the arithmetic operations you need to perform. For buffer sizes, prefer unsigned types – that way, you can easily check both overflow and underflow in one go, i.e. void f(uint8_t* buf, size_t bufSize) { // size_t is unsigned if (bufSize &lt; REASONABLE_SIZE) THROW(); // guards both against underflow and overflow! } Data Truncation Speaking of safely formatting data, be wary of truncated values. Importantly, make sure you do not truncate any important data when displaying on the Ledger screen. Example 1: Truncating tx hash from “f6954eb23ecd1d64c782e6d6c32fad2876003ae92986606585ae7187470d5e04” to “f695…5e04” might look nice for the users but this effectively reduces the security of hash and an attacker can now easily try to create a hash collision. Instead, prefer scrolling/paging of long such important values. Example 2: Raise errors instead of truncation int tmp[10]; // max 10 digits, right? uint32_t amount = 1987654321 SPRINTF(tmp, &quot;%d&quot;, amount) // at least we won&#39;t get buffer overflow here ... display(tmp) // but we display an empty screen! // but it could be worse // with bad custom formatting function we could get format_amount(tmp, SIZEOF(tmp), amount) // &quot;198765432&quot; or &quot;987654321&quot; Stack overflow You application has only a limited size (about ~700B) of stack. That is one of the reasons why stack cookies are not supported yet on the platform. Given the memory constraints, BOLOS OS does not have memory mapping which would protect from stack overflow errors. As a result, it is very easy to consume more stack space and overwrite the end of your data. Recommendation: Enable DEFINES += HAVE_BOLOS_APP_STACK_CANARY in your Makefile. This will help you detect stack overflows during app development. If overflow is detected, the app will reboot the device. Note that the overflow check happens only on the next I/O. This means that the protection is not instant and an attacker might avoid the canary check: this option is not a security feature, and has been added to analyze the stack usage during testing process. Optimizations Do not clear sensitive data with for-loops or other techniques. Do not user memset or bzero to clear sensitive data: it could be optimized and removed by the compiler. Recommendation: Use explicit_bzero which guarantees that the compiler will not remove the erasure. (See https://www.owasp.org/index.php/Insecure\\_Compiler\\_Optimization for an example of how things could go wrong.) Business logic problems Swallowing errors &amp; half-updated states It goes without saying that you should check return value of functions for any errors. Fortunately, BOLOS throws an error if something goes wrong and you might want to do the same instead of relying on error codes. There is, however, a more indirect problem. Some BOLOS apps silently catch exceptions in the main event loop without erasing app memory. This could lead into a following insidious bug: uint16_t totalSize; uint8_t totalBuf[1000]; void signTx(uint8_t p1, uint8_t p2, uint8_t* data, uint16_t dataSize) { if (p1 == P1_INIT) { totalSize = 0; } uint8_t* ptr = totalBuf[totalSize]; totalSize += dataSize; if (totalSize &gt; SIZEOF(totalBuf)) THROW(ERR); memcpy(ptr, data, dataSize); if (p2 == P2_CONTINUE) { THROW(0x9000); // early exit with success } do_something(); } An attacker might do SignTx(INIT, 100 bytes of data) // OK SignTx(CONTINUE, 100 bytes of data) // OK … SignTx(CONTINUE, 100 bytes of data) // OK SignTx(CONTINUE, 100 bytes of data) // throws … SignTx(CONTINUE, 100 bytes of data) // throws SignTx(CONTINUE, 100 bytes of data) // writes to data[-64..36] The problem here is that the app state is not updated in a “transactional” manner and attacker exploits this. Recommendations: Try to not affect global state before you throw. Many times you can use a scratch memory to assemble result and only then do memmove to write the result. Even better, wipe memory/reboot device on exceptions to destroy any half-updated app states. Too lenient parsing of transactions It might happen that your transaction parsing is too lenient. Importantly, this might cause problems if the transaction serialization spec is ambiguous and different clients might interpret it differently. For example, if a field might be repeated one parser might take the first value while another one a second. In general, lenient tx serialization spec should not happen (and if so, the cryptocurrency has bigger concerns than Ledger wallet). However, even if the network nodes are strict with the serialization checking, you should not slack off on your part. Any ambiguity in parsing adds an attacker a leverage point once it finds some other vulnerability. Recommendation: Be as strict as possible with transaction parsing. Accept only fields which are in normalized form. If possible, avoid repeated fields and accept fields only in a pre-described order. Note: you can even go further and do not parse transaction on the device at all. Instead, just send the data in a custom format and let both the app and host serialize the transaction on their own with the app revealing (and signing) only the serialized hash. This way you can avoid bugs in parsing code and be sure both the host wallet and the app agree perfectly on the content of the transaction. Protect Against “Instruction Change” Attacks Ledger applications live on a secure chip which is very limited in terms of its memory and communication channel. This brings in an interesting problem – the application might not be able to perform all its work in a single request. Instead, the work will need to be spread over multiple requests. Whenever this happens, the application needs to be protected against attacker mixing multiple non-related (or even related) requests. If your application contains at least one instruction which works over multiple APDU exchanges (e.g., having P1_INIT/P1_CONTINUE flag in the standard application “terminology”), you have to protect it from interference. Common attack scenarios: Example: Two multi-APDU instructions Let’s say you have SignTx and SignMessage, both sharing the same global hash variable, both instructions working over multiple APDU exchanges.The attacker might now call SignMessage(INIT) SignTx(INIT) SignMessage(CONTINUE) with data (no finish yet) SignTx(CONTINUE) with data (finish) At this point, the global memory might be in an inconsistent state (for example, the SignTx hash does contain a different hash than it should be). This might lead to an easy attack. Example: Single multi-APDU instruction Even if you have only a single instruction with multiple APDU exchanges, an attacker might gain some leverage. Let’s say you have roughly struct pubkey_ctx { int[10] bip32_path; int bip32_path_len; } struct sign_ctx { hash_ctx hash; // some other data } union { pubkey_ctx pubkey; sign_ctx signTx; } ctx; To overwrite the hash context with an exact chosen value. Example: “Self”-attack on a single multi-APDU instruction You don’t even need two instructions to perform a variation of the attack. Suppose your code goes along these lines void signTx () { if (p1 == P1_INIT) { initialize_half_of_my_state() if (some_bad_input) THROW(error) initialize_rest_of_the_state } else { // do something } } Assuming that you do not reset state on exceptions, this might happen signTx(INIT, valid data) signTx(CONTINUE, valid data) signTx(INIT, data which throws) signTx(CONTINUE, more data) An attacker now managed to reset half of your state (maybe tx length) but not the rest of it (maybe tx hash) which might allow it to attack your code. Obviously, there are many variations of this basic scheme and an utmost care needs to be taken here. The recommendation here is: Do not allow mixing of instructions Within instruction, keep an explicit state machine of what is allowed to happen next) Clear memory on exceptions Use explicit state machines Whenever a host is required to perform certain actions in a specific order, be sure to explicitly track the state and verify that the next step is consistent. Good examples of what might need to be checked If host claims some number of tx inputs/outputs, make sure you receive exactly that amount, not more and not less If the host needs to send multiple transaction inputs and outputs and you have to process inputs before outputs, make sure the host cannot send additional input after it received an output. Check that once you finished an action (signing), the attacker cannot resume with additional data (which might be empty). This is important, because usually signing “closes” some hash contexts (or destroy some other data) and re-running SignTx(CONTINUE, empty data) might, therefore, yield either crash or produce a signature of some different data. In general, after finishing a request you should wipe the context variable If you do not reset UI after sending APDU (for example, because you displayed an address and now you are waiting for another APDU containing tx amount), make sure your button handlers fire just once – a user might press the buttons multiple times. A general recommendation would be to always reset UI with APDU response. Additionally, you can guard your app against itself (and against bad SDK) with tracking whether it should be in IO/UI phase and assert on it in APDU/UI handlers. An (somewhat contrived) example of problematic button handlers void handle_sign_message(...) { ... // validations if (!is_last_apdu) { cx_hash(CX_CONTINUE, ctx-&gt;hash, data); else { memcpy(ctx-&gt;last_part, data); flags *= IO_ASYNCH; display_tx_prompt(); } } unsigned int io_seproxyhal_touch_tx_ok() { // for some reason we modify ctx state here cx_hash(CX_LAST, ctx-&gt;last_part); sign(ctx-&gt;last_part); // now do io_exchange // Warning: this might throw (host might do something weird with USB) // -&gt; user will press the button second time // -&gt; we do another round of cx_hash -&gt; efficiently signing io_exchange(....); // now reset UI ui_idle(); // &lt;-- this line resets button callback } A fully resilient solution would be void display_tx_prompt() { tx_prompt_handled = false; ... } unsigned int io_seproxyhal_touch_tx_ok() { assert(!tx_prompt_handled); tx_prompt_handled = true; ... } unsigned int io_seproxyhal_touch_tx_cancel() { assert(!tx_prompt_handled); tx_prompt_handled = true; ... } But such a solution is needed only if tx_ok or tx_cancel modify context/global variables before calling ui_idle(). (As a side note, if your__ok()/__cancel() handler both 1) do not check whether the memory is cleared, but 2) clear the memory inside the handler; make sure that memclear happens after calling ui_idle()). Note: If not guarded properly, an attacker might try a following line of attack: Send transaction which is not what user wanted User realizes that the transaction is wrong and presses reject Attacker hogs io_exchange (presumably by doing some bad things to USB communication) User tries again a few more times, thinks that the UI is broken and the app hanged. The callbacks are fired again and again but io_exchange still throws At this point in time, a desperate user might click on “confirm” button to unblock the UI. If an attacker can guess this time, she can un-hog USB and receive confirm callback","dateModified":"2021-04-22T15:38:24+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/docs/NA/a_security_guidelines/"},"url":"http://localhost:4000/docs/NA/a_security_guidelines/","author":{"@type":"Person","name":"pscott"},"@type":"BlogPosting","headline":"Developing Secure Ledger Apps","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <meta property="og:image" content="http://localhost:4000/uploads/"/>
  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="shortcut icon" type="image/png" href="/uploads/favicon.png" >
  <link rel="alternate" type="application/rss+xml" title="Ledger Developer pages" href="/feed.xml">
  <script src="/assets/js/main.js"></script>
  
    <script>
function searchResults(form) {

    var currentItem = null;
    var search = document.getElementById(form);
    var results = document.getElementById(form + "-results");
    var toggle = document.getElementById(form + "-toggle");

    function removeActive() {
        for (i = 0; i < results.children.length; i++) {
            results.children[i].classList.remove("uk-background-muted");
        }
    }

    // Detect all clicks on the document
    document.addEventListener("click", function(event) {

        var isClickSearch = false;
        var isClickResults = false;
        var isClickSearchToggle = false;

        if (search !== null) {
            isClickSearch = search.contains(event.target);
        }

        if (results !== null) {
            isClickResults = results.contains(event.target);
        }

        if (toggle !== null) {
            isClickSearchToggle = toggle.contains(event.target);
        }

        if (isClickSearch || isClickSearchToggle) {
            results.style.display = "block";
        }        

        if (!isClickResults && !isClickSearch && !isClickSearchToggle) {
            results.style.display = "none";
        }        
        
    });    

    results.addEventListener("mouseover", function(event) {

        removeActive();
        event.target.parentElement.classList.add("uk-background-muted");
        currentItem = null;

    });

    results.addEventListener("mouseout", function(event) {
        event.target.parentElement.classList.remove("uk-background-muted");
    });


    search.addEventListener("keyup", function(event) {

        var resultItems = results.children;
        var resultCount = results.children.length;
                                
        if (event.keyCode === 40) {

            if (currentItem < (resultCount - 1)) {
                if (currentItem === null) {
                    currentItem = 0;
                } else {
                    removeActive();
                    currentItem++;
                }
                removeActive();
                resultItems[currentItem].classList.add("uk-background-muted");
            }
            
        } else if (event.keyCode === 38) {

            if (currentItem > 0) {
                if (currentItem === null) {
                    currentItem = 0;
                } else {
                    removeActive();
                    currentItem--;
                }
                removeActive();
                resultItems[currentItem].classList.add("uk-background-muted");
            }

        } else if (event.keyCode === 13) {

            resultItems[currentItem].children[0].click();

        }

    });

}
</script>
  
  
  
<script src="http://127.0.0.1:35729/livereload.js"></script></head>

    <body>

    
        <div data-uk-sticky="animation: uk-animation-slide-top; sel-target: .uk-navbar-container; cls-active: uk-navbar-sticky; cls-inactive: uk-navbar-transparent; top: 200">
    <nav class="uk-navbar-container">
        <div class="uk-container">
            <div data-uk-navbar>
                <div class="uk-navbar-left">
                    <a class="uk-navbar-item uk-logo uk-visible@m" href="/">Ledger Developer pages</a>
                    
                        <a class="uk-navbar-toggle uk-hidden@m" href="#offcanvas-docs" data-uk-toggle><span data-uk-navbar-toggle-icon></span> <span class="uk-margin-small-left">Docs</span></a>
                    

                    <ul class="uk-navbar-nav uk-visible@m">
                        
                            
                            
                            
                                
                                    
                                        <li><a href="/docs/00_header/" >Creating content</a></li>
                                                                                                        
                                
                            
                        
                            
                            
                            
                                
                                    
                                        <li><a href="/docs/00_header/" >Tools & Frameworks</a></li>
                                                                                                        
                                
                            
                        
                            
                            
                            
                                
                                    
                                        <li><a href="/docs/00_header/" >Release notes</a></li>
                                                                                                        
                                
                            
                        
                            
                            
                            
                                
                                    
                                        <li><a href="/docs/00_header/" >Tutorials</a></li>
                                                                                                        
                                
                            
                        
                            
                            
                            
                                
                                    
                                        <li><a href="#">_Old</a>
                                        
                                            <div class="uk-navbar-dropdown">
                                                <ul class="uk-nav uk-navbar-dropdown-nav">
                                                    
                                                    
                                                        
                                                        
                                                        <li><a href="/docs/TMPL/installation/">Template docs</a></li>
                                                    
                                                    
                                                    
                                                        
                                                        
                                                        <li><a href="/blog/">Blog</a></li>
                                                    
                                                    
                                                    
                                                        <li class="uk-nav-header">Changelogs</li>
                                                    
                                                    
                                                </ul>
                                            </div>
                                        
                                        </li>
                                                                                                        
                                
                            
                        
                    </ul>
                </div>
                <div class="uk-navbar-center uk-hidden@m">
                    <a class="uk-navbar-item uk-logo" href="/">Ledger Developer pages</a>
                </div>
                <div class="uk-navbar-right">
                    
                        
                            <div>
                                <a id="search-navbar-toggle" class="uk-navbar-toggle" uk-search-icon href="#"></a>
                                <div class="uk-drop uk-background-default uk-border-rounded" uk-drop="mode: click; pos: left-center; offset: 0">
                                    <form class="uk-search uk-search-navbar uk-width-1-1" onsubmit="return false;">
                                        <input id="search-navbar" class="uk-search-input" type="search" placeholder="Search for answers" autofocus autocomplete="off">
                                    </form>
                                    <ul id="search-navbar-results" class="uk-position-absolute uk-width-1-1 uk-list"></ul>
                                </div>
                            </div>
                            <script>
                            SimpleJekyllSearch({
                                searchInput: document.getElementById('search-navbar'),
                                resultsContainer: document.getElementById('search-navbar-results'),
                                noResultsText: '<li class="no-results">No results found</li>',
                                searchResultTemplate: '<li><a href="{url}">{title}</a></li>',
                                json: "/search.json"
                            });
                            searchResults("search-navbar");
                            </script>
                        
                    

                    <ul class="uk-navbar-nav uk-visible@m">
                        
                    </ul>

                    
                        <a class="uk-navbar-toggle uk-hidden@m" href="#offcanvas" data-uk-toggle><span data-uk-navbar-toggle-icon></span> <span class="uk-margin-small-left">Menu</span></a>
                    

                </div>
            </div>
        </div>
    </nav>
</div>
    

    <div class="uk-section">
    <div class="uk-container">
        <div class="uk-grid-large" data-uk-grid>

            <div class="sidebar-fixed-width uk-visible@m">
                <div class="sidebar-docs uk-position-fixed uk-margin-top">
                    
                    <h5>Background Information</h5>
                    <ul class="uk-nav uk-nav-default doc-nav">
                    
                      
                      
                      <li class=""><a href="/docs/NA/bg_introduction/">Introduction</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/bg_personal_security_devices/">Personal Security Devices</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/bg_master_seed/">The Master Seed</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/bg_hd_keys/">HD Key Generation</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/bg_hd_use_cases/">Applications for HD Trees</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/bg_application_isolation/">Application Isolation</a></li>
                    
                    </ul>
                    
                    <h5>BOLOS Platform</h5>
                    <ul class="uk-nav uk-nav-default doc-nav">
                    
                      
                      
                      <li class=""><a href="/docs/NA/b_introduction/">Introduction</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/b_overview/">Overview</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/b_features/">BOLOS Features</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/b_hardware_architecture/">Hardware Architecture</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/b_application_environment/">Application Environment</a></li>
                    
                    </ul>
                    
                    <h5>Userspace Development</h5>
                    <ul class="uk-nav uk-nav-default doc-nav">
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_introduction/">Introduction</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_setup/">Setting it up</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_writing_apps/">Writing Apps</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_display_management/">Display Management</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_advanced_display_management/">Advanced display management</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_low_level_display_management/">Low-level display management</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_syscalls/">Interaction Between BOLOS and Apps</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_application_structure/">Application Structure and I/O</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_memory/">Persistent Storage and PIC</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_alignment/">Memory alignment</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_troubleshooting/">Common Pitfalls and Troubleshooting</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_debugging/">Application Debug</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_speculos/">Emulating devices with Speculos</a></li>
                    
                    </ul>
                    
                    <h5>Additional Resources</h5>
                    <ul class="uk-nav uk-nav-default doc-nav">
                    
                      
                      
                      <li class=""><a href="/docs/NA/a_publishing_an_app/">Publishing an Application</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/a_external_docs/">External Documentation</a></li>
                    
                      
                      
                      <li class="uk-active"><a href="/docs/NA/a_security_guidelines/">Developing Secure Ledger Apps</a></li>
                    
                    </ul>
                    
                </div>
            </div>

            <div class="uk-width-1-1 uk-width-expand@m">

                <article class="uk-article">

                    <h1 class="uk-article-title">Developing Secure Ledger Apps</h1>

                    <p class="uk-text-lead uk-text-muted">Ensuring your app is secure</p>

                    <div class="uk-article-meta uk-margin-top uk-margin-medium-bottom uk-flex uk-flex-middle">
                        


  
  <img class="uk-border-circle avatar" src="http://localhost:4000/uploads/avatar-pscott.jpg" alt="pscott">


<div>
  
    Written by <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">pscott</span></span><br>
  
  <time datetime="" itemprop="datePublished">
    
    
  </time>
</div>
                    </div>

                    <div class="article-content link-primary">
                        <h4 class="no_toc" id="sections-in-this-article">Sections in this article</h4>
<ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a>    <ul>
      <li><a href="#development-practices" id="markdown-toc-development-practices">Development practices</a>        <ul>
          <li><a href="#code-reviews" id="markdown-toc-code-reviews">Code reviews</a></li>
          <li><a href="#security-audits" id="markdown-toc-security-audits">Security audits</a></li>
          <li><a href="#developing-first-app" id="markdown-toc-developing-first-app">Developing First App</a></li>
        </ul>
      </li>
      <li><a href="#cryptography" id="markdown-toc-cryptography">Cryptography</a>        <ul>
          <li><a href="#own-crypto-primitives" id="markdown-toc-own-crypto-primitives">Own crypto primitives</a></li>
          <li><a href="#avoid-blindly-signing-data" id="markdown-toc-avoid-blindly-signing-data">Avoid blindly signing data</a></li>
          <li><a href="#restrict-apps-to-coin-specific-bip32-prefix" id="markdown-toc-restrict-apps-to-coin-specific-bip32-prefix">Restrict Apps to Coin-Specific BIP32 Prefix</a></li>
          <li><a href="#signingdisclosing-keys-without-user-approval" id="markdown-toc-signingdisclosing-keys-without-user-approval">Signing/disclosing keys without user approval</a></li>
          <li><a href="#private-key-management" id="markdown-toc-private-key-management">Private Key Management</a></li>
          <li><a href="#be-wary-of-untrusted-input" id="markdown-toc-be-wary-of-untrusted-input">Be Wary of Untrusted Input</a></li>
          <li><a href="#properly-protect-data-you-wish-to-cache-on-the-host-computer" id="markdown-toc-properly-protect-data-you-wish-to-cache-on-the-host-computer">Properly protect data you wish to cache on the host computer</a></li>
          <li><a href="#do-not-allow-the-host-to-freely-manipulate-with-key-pairs" id="markdown-toc-do-not-allow-the-host-to-freely-manipulate-with-key-pairs">Do not allow the host to freely manipulate with key-pairs</a></li>
        </ul>
      </li>
      <li><a href="#c-is-your-enemy" id="markdown-toc-c-is-your-enemy">C is your enemy</a>        <ul>
          <li><a href="#know-your-c-compiler" id="markdown-toc-know-your-c-compiler">Know your C compiler</a></li>
          <li><a href="#use-safe-macro-constructs" id="markdown-toc-use-safe-macro-constructs">Use safe macro constructs</a></li>
          <li><a href="#buffer-overflowsunderflows" id="markdown-toc-buffer-overflowsunderflows">Buffer overflows/underflows</a></li>
          <li><a href="#integer-overflowsunderflows" id="markdown-toc-integer-overflowsunderflows">Integer overflows/underflows</a></li>
          <li><a href="#data-truncation" id="markdown-toc-data-truncation">Data Truncation</a></li>
          <li><a href="#stack-overflow" id="markdown-toc-stack-overflow">Stack overflow</a></li>
          <li><a href="#optimizations" id="markdown-toc-optimizations">Optimizations</a></li>
        </ul>
      </li>
      <li><a href="#business-logic-problems" id="markdown-toc-business-logic-problems">Business logic problems</a>        <ul>
          <li><a href="#swallowing-errors--half-updated-states" id="markdown-toc-swallowing-errors--half-updated-states">Swallowing errors &amp; half-updated states</a></li>
          <li><a href="#too-lenient-parsing-of-transactions" id="markdown-toc-too-lenient-parsing-of-transactions">Too lenient parsing of transactions</a></li>
          <li><a href="#protect-against-instruction-change-attacks" id="markdown-toc-protect-against-instruction-change-attacks">Protect Against “Instruction Change” Attacks</a>            <ul>
              <li><a href="#example-two-multi-apdu-instructions" id="markdown-toc-example-two-multi-apdu-instructions">Example: Two multi-APDU instructions</a></li>
              <li><a href="#example-single-multi-apdu-instruction" id="markdown-toc-example-single-multi-apdu-instruction">Example: Single multi-APDU instruction</a></li>
              <li><a href="#example-self-attack-on-a-single-multi-apdu-instruction" id="markdown-toc-example-self-attack-on-a-single-multi-apdu-instruction">Example: “Self”-attack on a single multi-APDU instruction</a></li>
            </ul>
          </li>
          <li><a href="#use-explicit-state-machines" id="markdown-toc-use-explicit-state-machines">Use explicit state machines</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>Developing applications for Ledger devices (Nano S, X, Blue) is an
intricate process. The security of the user funds relies on the fact
that the application works in a correct and secure manner and that
potential attackers cannot misuse it to extract private data and/or sign
requests which are not authorized by the user. The app should guard
against such attacks because they have a very low entry point – a
Ledger device attached to a compromised host might be a victim of the
attacker’s program sending invalid/non-standard requests to the device.</p>

<p>This guide is meant to be a summary of all important aspects of Ledger
Apps security and it shall be read by developers before developing an
app for Ledger. The guide is divided into multiple sections, each taking
on a different aspect of security.</p>

<h3 id="development-practices">Development practices</h3>

<p>Whenever writing a secure Ledger app, the following advice should not be
taken lightly.</p>

<h4 id="code-reviews">Code reviews</h4>

<p>We encourage all written code to be peer-reviewed. Importantly, the
review should have at least:</p>

<ol>
  <li>One reviewer proficient in C and knowing C security weaknesses.</li>
  <li>One reviewer with “hacker’s mind” (looking at the code from the
perspective of an attacker).</li>
</ol>

<h4 id="security-audits">Security audits</h4>

<p>We encourage third-party security reviews. Note, however, that solid
review takes time and a short review might yield a false sense of
security (especially if the reviewing party does not have an extensive
knowledge of Ledger code specifics).</p>

<h4 id="developing-first-app">Developing First App</h4>

<p>Apart from reading developer documentation at
<a href="https://ledger.readthedocs.io/en/latest/">https://ledger.readthedocs.io/en/latest/</a> we recommend looking at Sia
app <a href="https://github.com/LedgerHQ/ledger-app-sia">https://github.com/LedgerHQ/ledger-app-sia</a> which provides a nice
starting point for an app, including lots of explanatory comments. A
sample of security-wise overly-paranoid app is
<a href="https://github.com/LedgerHQ/ledger-app-cardano">https://github.com/LedgerHQ/ledger-app-cardano</a>.</p>

<h3 id="cryptography">Cryptography</h3>

<p>This section presents general concepts about cryptography development,
but also guidelines specific to the security model of the Ledger
devices. It gives guidelines to:</p>

<ul>
  <li>Ensure a potential vulnerability in one application will not cause
damages to other apps.</li>
  <li>Make sure all the operations that manipulate secrets are approved by
the user.</li>
  <li>Restrict the use of these secrets by apps.</li>
</ul>

<h4 id="own-crypto-primitives">Own crypto primitives</h4>

<p><strong>You should never roll your own crypto primitives</strong> (including
encryption/derivation schemes, hashing functions, HMAC, etc.)</p>

<p>Rationale: It is a purpose of BOLOS operating system to perform these in
a secure manner. Importantly, writing your own crypto primitives is
likely to open you to side-channel attacks or other problems. If your
primitive is not supported by BOLOS (e.g., some very new cryptography),
consult with Ledger developers the possibility of including it in the
OS.</p>

<h4 id="avoid-blindly-signing-data">Avoid blindly signing data</h4>

<p><strong>You should never allow signing of any attacker-controlled message
unless it has been verified for structural validity. Importantly, you
should never sign a message that might be a hash of transaction.</strong></p>

<p>Rationale: If you allow an attacker to blindly sign a message, she can
easily supply a hash of a valid transaction. Your signature could then
be used to send an unauthorized transaction.</p>

<p>If you want to sign user-supplied “personal” messages, prefix them with
a fixed string (which shouldn’t be a valid transaction prefix). It is
also a good practice to include message length in the text to be signed.
Ledger-app-eth has a good example in function
<code class="language-plaintext highlighter-rouge">handleSignPersonalMessage</code>. Note that sometimes cryptocurrencies have a
standardized way of signing such personal messages and in that case you
should use the approved scheme.</p>

<p>Warning: If you allow signing untrusted hashes (while displaying a
prompt to the user), be aware that</p>

<ol>
  <li>Users do not understand security and could be easily tricked. In
fact, they will probably click through your prompt without thinking
unless you give them explicit “Warning: this is a very unusual
operation. Do not continue unless you know what you are doing”
warning. They might not listen even then</li>
  <li>A compromised host might both change hash on the screen and also
data sent to device. This opens the possibility of users signing
something they didn’t want to.</li>
</ol>

<h4 id="restrict-apps-to-coin-specific-bip32-prefix">Restrict Apps to Coin-Specific BIP32 Prefix</h4>

<p>BIP32 paths on which the app can derive keys must be restricted in your
application. The chosen derivation paths must not conflict with existing
paths if the use case differs.</p>

<div class="warning">

<div class="title">

Warning

</div>

Ledger will not sign apps whose BIP32 prefixes have not been properly
set.

</div>

<p>Restricting the derivation path can be done by setting the <code class="language-plaintext highlighter-rouge">--path</code>
property in the app Makefile.</p>

<p>For example, if your application derive keys on the hardened path
44’/60’, specify in your Makefile:</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">APP_LOAD_PARAMS</span> <span class="o">+=</span> <span class="nt">--path</span> <span class="s2">"44'/60'"</span>
</code></pre></div></div>

<p>Derivation can also be restricted to a specific curve using the
<code class="language-plaintext highlighter-rouge">--curve</code> property. Supported curves are <code class="language-plaintext highlighter-rouge">secp256k1</code>, <code class="language-plaintext highlighter-rouge">prime256r1</code> and
<code class="language-plaintext highlighter-rouge">ed25519</code>.</p>

<p>Several curves and paths can be configured. For example, if your app
must derive keys on paths 44’/535348’, 13’ and 17’, on curves Ed25519
and prime256r1, the Makefile should contain:</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">APP_LOAD_PARAMS</span><span class="o">=</span><span class="nt">--curve</span> ed25519 <span class="nt">--curve</span> prime256r1 <span class="nt">--path</span> <span class="s2">"44'/535348'"</span> <span class="nt">--path</span> <span class="s2">"13'"</span> <span class="nt">--path</span> <span class="s2">"17'"</span>
</code></pre></div></div>

<p>Rationale: Setting prefixes is crucial, as it limites the amount of
damages an attacker can do if he manages to compromise an application.
If a vulnerability is exploited on a poorly written of backdoored
application, an attacker should not be able to exploit it to extract
private keys from other apps, such as Bitcoin or Ethereum keys.</p>

<div class="warning">

<div class="title">

Warning

</div>

If your application derives keys on the hardened path 44'/60' then the
chainID parameter must be different from 0 or 1. This is necessary to
avoid replaying transactions broadcoast on Ethereum-like chains on
Ethereum. As a general recommendation, and to ensure a good level of
privacy for the end user, we recommend to always use the correct coin
type in the derivation path as defined in slip44
(&lt;https://github.com/satoshilabs/slips/blob/master/slip-0044.md&gt;)

</div>

<h4 id="signingdisclosing-keys-without-user-approval">Signing/disclosing keys without user approval</h4>

<div class="warning">

<div class="title">

Warning

</div>

You must always require user approval for signing transactions/messages.

</div>

<p>Rationale: If you do not require user consent for signing important
data, an attacker can use your device as a signing black box and sign
whatever it wants.</p>

<div class="note">

<div class="title">

Note

</div>

You might also consider approvals for extracting public keys, as some
users might want extended privacy.

1.  They might not want to reveal their *root/account* public key, only
    address keys
2.  They might not want to reveal address public key until it is
    required. (Some cryptocurrencies use addresses that are hash of
    public keys. It is therefore enough to send the address to the
    host).

Note that there is a trade-off between privacy and usability here. If
you want privacy, it would require a user interaction every time they
want to use Ledger device, as opposed to only interaction while signing
transactions. The behaviour could also be manually set in the
application options.

</div>

<h4 id="private-key-management">Private Key Management</h4>

<p><strong>You should minimize the code that works with private (ECDSA, RSA,
etc.) or secret (HMAC, AES, etc.) keys.</strong> Importantly, you should always
<strong>clear the memory</strong> after you use these keys. That includes key data
and key objects.</p>

<p>Leaving parts of private or secret keys lying around in memory is not a
security issue on its own because there is no easy way to extract the
content of RAM on the chip. If a key is left in RAM by an app, another
app will not be able to access it.</p>

<p>However, if the key has not been properly erased, a security issue could
lead to the leak of this key, even if it is not used anymore. An
attacker able to read arbitrary memory from the app, or execute
arbitrary code, will be able to read the content of the stack segment,
hence the parts of the key which have not been erased.</p>

<p>A common (and wrong) way of doing this:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint8_t</span> <span class="n">privateKeyData</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="n">cx_ecfp_private_key_t</span> <span class="n">privateKey</span><span class="p">;</span>

<span class="n">os_perso_derive_node_bip32</span><span class="p">(</span>
    <span class="n">tmpCtx</span><span class="p">.</span><span class="n">transactionContext</span><span class="p">.</span><span class="n">curve</span><span class="p">,</span> <span class="n">tmpCtx</span><span class="p">.</span><span class="n">transactionContext</span><span class="p">.</span><span class="n">bip32Path</span><span class="p">,</span>
    <span class="n">tmpCtx</span><span class="p">.</span><span class="n">transactionContext</span><span class="p">.</span><span class="n">pathLength</span><span class="p">,</span> <span class="n">privateKeyData</span><span class="p">,</span>
    <span class="nb">NULL</span><span class="p">);</span>
<span class="n">cx_ecfp_init_private_key</span><span class="p">(</span><span class="n">tmpCtx</span><span class="p">.</span><span class="n">transactionContext</span><span class="p">.</span><span class="n">curve</span><span class="p">,</span> <span class="n">privateKeyData</span><span class="p">,</span>
                         <span class="mi">32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">privateKey</span><span class="p">);</span>
<span class="n">explicit_bzero</span><span class="p">(</span><span class="n">privateKeyData</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">privateKeyData</span><span class="p">));</span>

<span class="c1">// (later, after privateKey is not needed)</span>
<span class="n">explicit_bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">privateKey</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">privateKey</span><span class="p">));</span>
</code></pre></div></div>

<p>In the happy path, the previous code will correctly clean the memory
once the private key is initialized. Note, however, that this code
<strong>fails to protect private key in case some system call throws (for
example cx_ecfp_init_private_key)</strong>. Correct code should wrap the
clearing in
<code class="language-plaintext highlighter-rouge">BEGIN_TRY { TRY { ... } FINALLY { explicit_bzero() } END_TRY;</code>.</p>

<p>Applications where such issues were fixed include <a href="https://github.com/LedgerHQ/app-ark/commit/e84a4dc0c422f7ade586c831cbab56cb15c64df1">the ARK
app</a>
and <a href="https://github.com/LedgerHQ/app-solana/pull/5/files">the Solana
app</a>.</p>

<h4 id="be-wary-of-untrusted-input">Be Wary of Untrusted Input</h4>

<p>Some cryptocurrencies do not have <em>explicit</em> fee encoded in the
transaction. In such cases, the app cannot rely on fee value sent from
the host. Instead, it should receive previous UTxOs and check their
output amounts. Note that this usually needs to be done in a separate
step due to memory constraints. Check with BTC/Cardano app design for
this.</p>

<h4 id="properly-protect-data-you-wish-to-cache-on-the-host-computer">Properly protect data you wish to cache on the host computer</h4>

<p>Sometimes your app needs to compute over more data than it can fit
inside memory. Taking an example from the previous section, it might not
be easy to store all UTxOs in memory of Ledger. As such, you might break
computation into multiple steps and, for example, verify each UTxO
separately and let the host computer to cache a “certified summary”. If
you do this, be aware that</p>

<ol>
  <li>
    <p>If the information you want the host to cache is public, you still
need to attach a signature to it so that the host cannot send some
other value later. This could be done with standard HMAC digest. We
would recommend using a temporary (per session) key for this
–having a per-session HMAC allows you to truncate the digest size
(e.g., you don’t need to have HMAC which withstands years of
brute-force attack. Instead, you can balance the digest size against
some reasonable upper bound on how long the session lives (e.g., one
month should be enough)).</p>
  </li>
  <li>
    <p>If the information is not public, you need to both encrypt and
provide a signature. Notably, it is not enough to “scramble” the
data by XORing with a random key as this would still allow the
attacker to tamper with the values. (Or even break the scrambling if
you re-use the same key).</p>

    <p>Instead:</p>

    <ul>
      <li>Encrypt the information with a sufficiently strong cipher</li>
      <li>Provide a digest to avoid tampering with the value</li>
    </ul>
  </li>
</ol>

<h4 id="do-not-allow-the-host-to-freely-manipulate-with-key-pairs">Do not allow the host to freely manipulate with key-pairs</h4>

<p>Some cryptocurrencies (notably Monero) need to perform an extensive
calculation with <em>(public, private)</em> key-pair spread over multiple APDU
exchanges. If you need to do the same, <strong>do not</strong> allow the attacker to
step out of the protocol. Notably, allowing the attacker to freely
perform key manipulation (e.g., group multiplications, exponentiations,
etc.) could undermine your app security <strong>even if the private key never
leaves the device</strong>. In general, keep an explicit protocol state machine
during the computation. Also, consult with cryptography experts to check
for implications if you misstep from the protocol.</p>

<h3 id="c-is-your-enemy">C is your enemy</h3>

<h4 id="know-your-c-compiler">Know your C compiler</h4>

<p>Ledger apps are written in C. Unlike typical embedded project, the goal
here is to write for a single platform with a single compiler.</p>

<p>The current supported compiler is clang, and it supports newest language
features (up to C11). This is useful for both development and security.
You should really learn about the new features and use them extensively
as they might help you writing more secure code.</p>

<p>A random collection of useful features: intermingled declarations and
code, support of <code class="language-plaintext highlighter-rouge">_Generic</code>, <code class="language-plaintext highlighter-rouge">_Static_assert</code>,
<code class="language-plaintext highlighter-rouge">__builtin_types_compatible_p</code>, <code class="language-plaintext highlighter-rouge">__typeof</code> (very useful for safer
versions of macros), etc.</p>

<h4 id="use-safe-macro-constructs">Use safe macro constructs</h4>

<p>C is a minefield of problems related to pointers. You can alleviate some
of the problems with good macros. However, beware of when they can fail.
For example, take the following code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define ARRAY_LEN(a) sizeof(a) / sizeof(a[0])
</span></code></pre></div></div>

<p>Apart from the “obvious” problem of ARRAY_LEN macro being written
without external parenthesis, making code such as</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="n">ARRAY_LEN</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>compile to what is understood by the compiler as</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</code></pre></div></div>

<p>there is an important problem with this macro. If used in the function
like this</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">fn</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">ARRAY_LEN</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The result is unexpectedly len=1. The reason is that <code class="language-plaintext highlighter-rouge">int x[10]</code> in the
function header is silently converted into <code class="language-plaintext highlighter-rouge">int* x</code> and the length is
therefore <code class="language-plaintext highlighter-rouge">sizeof(ptr) / sizeof(int)</code> which is indeed 1 on the platform.
You can read more about the problem and how to define a safe version in
<a href="http://zubplot.blogspot.com/2015/01/gcc-is-wonderful-better-arraysize-macro.html">http://zubplot.blogspot.com/2015/01/gcc-is-wonderful-better-arraysize-macro.html</a>
which explains a patch to the Linux kernel to improve safety of its
ARRAY_SIZE macro.</p>

<p>Note that similar problems exist, if x is a pointer, with:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">memset</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</code></pre></div></div>

<p>In general, if writing macros, try to write them in a way that they will
fail if they get a pointer instead of struct/array.</p>

<h4 id="buffer-overflowsunderflows">Buffer overflows/underflows</h4>

<p>Buffer overflows and underflows are perhaps the biggest source of
security vulnerabilities in C code. The following example shows a buffer
overflow in (a past version) of one Ledger app.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define MAX_RAW_TX 200
</span><span class="p">...</span>
<span class="k">struct</span> <span class="n">tmpCtx</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">uint8_t</span> <span class="n">rawTx</span><span class="p">[</span><span class="n">MAX_RAW_TX</span><span class="p">];</span>
<span class="p">}</span> <span class="n">transactionContext_t</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">PREFIX</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x02</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// coin-specific signing prefix</span>

<span class="kt">void</span> <span class="nf">handleSign</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">p1</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">p2</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">workBuffer</span><span class="p">,</span>
                <span class="kt">uint16_t</span> <span class="n">dataLength</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span>
                <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">tx</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// (no dataLength validation, we can get up to 255 from APDU)</span>
    <span class="c1">// Note: we can pass this line with dataLength &gt; 200</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">parseTx</span><span class="p">(</span><span class="n">workBuffer</span><span class="p">,</span> <span class="n">dataLength</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txContent</span><span class="p">)</span> <span class="o">!=</span> <span class="n">USTREAM_FINISHED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">THROW</span><span class="p">(</span><span class="mh">0x6A80</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span>
    <span class="n">memmove</span><span class="p">(</span><span class="n">tmpCtx</span><span class="p">.</span><span class="n">rawTx</span><span class="p">,</span> <span class="n">PREFIX</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PREFIX</span><span class="p">));</span>

    <span class="c1">// Here is the vulnerability. There should be a check of</span>
    <span class="c1">// if (!(dataLength + sizeof(SIGN_PREFIX) &lt; MAX_RAW_TX)) THROW(...)</span>
    <span class="n">memmove</span><span class="p">(</span><span class="n">tmpCtx</span><span class="p">.</span><span class="n">transactionContext</span><span class="p">.</span><span class="n">rawTx</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SIGN_PREFIX</span><span class="p">),</span> <span class="n">workBuffer</span><span class="p">,</span> <span class="n">dataLength</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In general, there is only a single remedy for buffer overflows -<strong>always
check for available buffer space before writing to memory</strong>. The best is
to not rely on some specific buffer size but instead rely on sizeof
operator. If using sizeof, however, be very careful - if you ever pass a
buffer to a function, you are losing its size!</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint8_t</span> <span class="n">a</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>

<span class="n">main</span><span class="p">()</span> <span class="p">{</span>
 <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// 100</span>
 <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
 <span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// 4 </span>
<span class="p">}</span> 

<span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">oops</span><span class="p">[</span><span class="mi">100</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">sizeof</span><span class="p">(</span><span class="n">oops</span><span class="p">);</span> <span class="c1">// 4</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For the extra safery, consider using a SIZEOF macro defined similarly to
<a href="https://github.com/LedgerHQ/ledger-app-cardano/blob/f578c903c19288495a359a2bc909b39c33ee69ca/src/utils.h#L27">https://github.com/LedgerHQ/ledger-app-cardano/blob/f578c903c19288495a359a2bc909b39c33ee69ca/src/utils.h#L27</a></p>

<p>Be also wary of constructs like</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">memset</span><span class="p">(</span><span class="n">displayAddress</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fullAddress</span><span class="p">));</span>
<span class="n">memmove</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">displayAddress</span><span class="p">,</span> <span class="n">tmpCtx</span><span class="p">.</span><span class="n">address</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="n">memmove</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">displayAddress</span> <span class="o">+</span> <span class="mi">5</span><span class="p">),</span> <span class="s">"..."</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">memmove</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">displayAddress</span> <span class="o">+</span> <span class="mi">8</span><span class="p">),</span> <span class="n">tmpCtx</span><span class="p">.</span><span class="n">address</span> <span class="o">+</span> <span class="n">addressLength</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</code></pre></div></div>

<p>There are several problematic aspects of such code. Apart from
truncating important values (see next sections), this code makes a lot
of assumptions. For example, if addressLength &lt; 4 (maybe some
previous function returns addressLength=0 instead of an error) we get
buffer underflow and copy up to 4 bytes of other memory and display it
to the user. Or a programmer decides to shorten definition of
fullAddress below 13 and we would overwrite memory after the buffer.
Finally, this code uses explicit indexes (e.g., 5, 8=5+3). A better
trick would be to have a safe helper macro:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define APPEND(ptr, end, from, len) \
  do { \
    if (ptr + len &gt;= end || len &lt; 0) THROW(); // not enough space \
    memcpy(ptr, from, len); \
    ptr += len; \
  } while(0)
</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">ptr_begin</span> <span class="o">=</span> <span class="n">displayAddress</span><span class="p">;</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">ptr_end</span> <span class="o">=</span> <span class="n">displayAddress</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">displayAddress</span><span class="p">);</span> <span class="c1">// points behind buffer</span>
<span class="n">APPEND</span><span class="p">(</span><span class="n">ptr_begin</span><span class="p">,</span> <span class="n">ptr_end</span><span class="p">,</span> <span class="n">tmpCtx</span><span class="p">.</span><span class="n">address</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// we should also assert addressLength&gt;5</span>
<span class="n">APPEND</span><span class="p">(</span><span class="n">ptr_begin</span><span class="p">,</span> <span class="n">ptr_end</span><span class="p">,</span> <span class="s">"..."</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// Note, we still have explicit size here</span>
<span class="n">APPEND</span><span class="p">(</span><span class="n">ptr_begin</span><span class="p">,</span> <span class="n">ptr_end</span><span class="p">,</span> <span class="n">tmpCtx</span><span class="p">.</span><span class="n">address</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// Note: another assert</span>
</code></pre></div></div>

<p>Finally, you can use SPRINTF macro from <code class="language-plaintext highlighter-rouge">sdk/include/os_io_seproxyhal.h</code>
but be aware that the definition is</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define SPRINTF(strbuf, ...) snprintf(strbuf, sizeof(strbuf), __VA_ARGS__)
</span></code></pre></div></div>

<p>so the above warning about passing pointers instead of arrays applies to
it.</p>

<h4 id="integer-overflowsunderflows">Integer overflows/underflows</h4>

<p>Integer overflows go hand in hand with buffer overflows. In fact, they
can cause serious buffer overflows. Consider following code where a
numeric underflow causes buffer overflow of 64kB!</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">handleSign</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">p1</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">p2</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">workBuffer</span><span class="p">,</span>
                <span class="kt">uint16_t</span> <span class="n">dataLength</span><span class="p">,</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span>
                <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">tx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="c1">// here we don't check if dataLength &gt; 0 so we might be reading behind the buffer</span>
    <span class="n">tmpCtx</span><span class="p">.</span><span class="n">transactionContext</span><span class="p">.</span><span class="n">pathLength</span> <span class="o">=</span> <span class="n">workBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">tmpCtx</span><span class="p">.</span><span class="n">transactionContext</span><span class="p">.</span><span class="n">pathLength</span> <span class="o">&lt;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">||</span>
        <span class="p">(</span><span class="n">tmpCtx</span><span class="p">.</span><span class="n">transactionContext</span><span class="p">.</span><span class="n">pathLength</span> <span class="o">&gt;</span> <span class="n">MAX_BIP32_PATH</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">PRINTF</span><span class="p">(</span><span class="s">"Invalid path</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">THROW</span><span class="p">(</span><span class="mh">0x6a80</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">workBuffer</span><span class="o">++</span><span class="p">;</span>
    <span class="n">dataLength</span><span class="o">--</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tmpCtx</span><span class="p">.</span><span class="n">transactionContext</span><span class="p">.</span><span class="n">pathLength</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">tmpCtx</span><span class="p">.</span><span class="n">transactionContext</span><span class="p">.</span><span class="n">bip32Path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
            <span class="p">(</span><span class="n">workBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">workBuffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
            <span class="p">(</span><span class="n">workBuffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">workBuffer</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
        <span class="n">workBuffer</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
        <span class="c1">// here we again blindly assume dataLength &gt;= 4</span>
        <span class="n">dataLength</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">initTxContext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txProcessingCtx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sha256</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dataSha256</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txContent</span><span class="p">,</span> <span class="n">N_storage</span><span class="p">.</span><span class="n">dataAllowed</span><span class="p">);</span>
    <span class="c1">// if we sent APDU with dataLength=0 at the beginning, we would end up with dataLength ~ 64kB here</span>
    <span class="n">txResult</span> <span class="o">=</span> <span class="n">parseTx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txProcessingCtx</span><span class="p">,</span> <span class="n">workBuffer</span><span class="p">,</span> <span class="n">dataLength</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As a general rule, be very careful about variables which might overflow
or underflow. If possible, use bigger types that can accommodate the
arithmetic operations you need to perform. For buffer sizes, prefer
unsigned types – that way, you can easily check both overflow and
underflow in one go, i.e.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bufSize</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// size_t is unsigned</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bufSize</span> <span class="o">&lt;</span> <span class="n">REASONABLE_SIZE</span><span class="p">)</span> <span class="n">THROW</span><span class="p">();</span> <span class="c1">// guards both against underflow and overflow!</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="data-truncation">Data Truncation</h4>

<p>Speaking of safely formatting data, be wary of truncated values.
Importantly, make sure you do not truncate any important data when
displaying on the Ledger screen.</p>

<p>Example 1: Truncating tx hash from
“f6954eb23ecd1d64c782e6d6c32fad2876003ae92986606585ae7187470d5e04” to
“f695…5e04” might look nice for the users but this effectively reduces
the security of hash and an attacker can now easily try to create a hash
collision. Instead, prefer scrolling/paging of long such important
values.</p>

<p>Example 2: Raise errors instead of truncation</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// max 10 digits, right?</span>

<span class="kt">uint32_t</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">1987654321</span>
<span class="n">SPRINTF</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s">"%d"</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span> <span class="c1">// at least we won't get buffer overflow here ...</span>
<span class="n">display</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="c1">// but we display an empty screen!</span>

<span class="c1">// but it could be worse</span>
<span class="c1">// with bad custom formatting function we could get</span>
<span class="n">format_amount</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">SIZEOF</span><span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="n">amount</span><span class="p">)</span> <span class="c1">// "198765432" or "987654321"</span>
</code></pre></div></div>

<h4 id="stack-overflow">Stack overflow</h4>

<p>You application has only a limited size (about ~700B) of stack. That is
one of the reasons why stack cookies are not supported yet on the
platform.</p>

<p>Given the memory constraints, BOLOS OS does not have memory mapping
which would protect from stack overflow errors. As a result, it is very
easy to consume more stack space and overwrite the end of your data.</p>

<p>Recommendation:</p>

<p>Enable <code class="language-plaintext highlighter-rouge">DEFINES += HAVE_BOLOS_APP_STACK_CANARY</code> in your Makefile. This
will help you detect stack overflows during app development. If overflow
is detected, the app will reboot the device. Note that the overflow
check happens only on the next I/O. This means that the protection is
not instant and an attacker might avoid the canary check: this option is
not a security feature, and has been added to analyze the stack usage
during testing process.</p>

<h4 id="optimizations">Optimizations</h4>

<p>Do not clear sensitive data with for-loops or other techniques. Do not
user <code class="language-plaintext highlighter-rouge">memset</code> or <code class="language-plaintext highlighter-rouge">bzero</code> to clear sensitive data: it could be optimized
and removed by the compiler.</p>

<p>Recommendation: Use <code class="language-plaintext highlighter-rouge">explicit_bzero</code> which guarantees that the compiler
will not remove the erasure. (See
<a href="https://www.owasp.org/index.php/Insecure\_Compiler\_Optimization">https://www.owasp.org/index.php/Insecure\_Compiler\_Optimization</a>
for an example of how things could go wrong.)</p>

<h3 id="business-logic-problems">Business logic problems</h3>

<h4 id="swallowing-errors--half-updated-states">Swallowing errors &amp; half-updated states</h4>

<p>It goes without saying that you should check return value of functions
for any errors. Fortunately, BOLOS throws an error if something goes
wrong and you might want to do the same instead of relying on error
codes.</p>

<p>There is, however, a more indirect problem. Some BOLOS apps silently
catch exceptions in the main event loop without erasing app memory. This
could lead into a following insidious bug:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint16_t</span> <span class="n">totalSize</span><span class="p">;</span>
<span class="kt">uint8_t</span> <span class="n">totalBuf</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">signTx</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">p1</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">p2</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">dataSize</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">==</span> <span class="n">P1_INIT</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">totalSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">totalBuf</span><span class="p">[</span><span class="n">totalSize</span><span class="p">];</span>
  <span class="n">totalSize</span> <span class="o">+=</span> <span class="n">dataSize</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">totalSize</span> <span class="o">&gt;</span> <span class="n">SIZEOF</span><span class="p">(</span><span class="n">totalBuf</span><span class="p">))</span> <span class="n">THROW</span><span class="p">(</span><span class="n">ERR</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">dataSize</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">p2</span> <span class="o">==</span> <span class="n">P2_CONTINUE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">THROW</span><span class="p">(</span><span class="mh">0x9000</span><span class="p">);</span> <span class="c1">// early exit with success</span>
  <span class="p">}</span>
  <span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>An attacker might do</p>

<ol>
  <li>SignTx(INIT, 100 bytes of data) // OK</li>
  <li>SignTx(CONTINUE, 100 bytes of data) // OK</li>
</ol>

<p>…</p>

<ol>
  <li>SignTx(CONTINUE, 100 bytes of data) // OK</li>
  <li>SignTx(CONTINUE, 100 bytes of data) // throws</li>
</ol>

<p>…</p>

<ol>
  <li>SignTx(CONTINUE, 100 bytes of data) // throws</li>
  <li>SignTx(CONTINUE, 100 bytes of data) <strong>// writes to data[-64..36]</strong></li>
</ol>

<p>The problem here is that the app state is not updated in a
“transactional” manner and attacker exploits this.</p>

<p>Recommendations: Try to not affect global state before you throw. Many
times you can use a scratch memory to assemble result and only then do
<code class="language-plaintext highlighter-rouge">memmove</code> to write the result. Even better, wipe memory/reboot device on
exceptions to destroy any half-updated app states.</p>

<h4 id="too-lenient-parsing-of-transactions">Too lenient parsing of transactions</h4>

<p>It might happen that your transaction parsing is too lenient.
Importantly, this might cause problems if the transaction serialization
spec is ambiguous and different clients might interpret it differently.
For example, if a field might be repeated one parser might take the
first value while another one a second. In general, lenient tx
serialization spec should not happen (and if so, the cryptocurrency has
bigger concerns than Ledger wallet).</p>

<p>However, even if the network nodes are strict with the serialization
checking, you should not slack off on your part. Any ambiguity in
parsing adds an attacker a leverage point once it finds some other
vulnerability.</p>

<p>Recommendation: Be as strict as possible with transaction parsing.
Accept only fields which are in normalized form. If possible, avoid
repeated fields and accept fields only in a pre-described order.</p>

<p>Note: you can even go further and do not parse transaction on the device
at all. Instead, just send the data in a custom format and let both the
app and host serialize the transaction on their own with the app
revealing (and signing) only the serialized hash. This way you can avoid
bugs in parsing code and be sure both the host wallet and the app agree
perfectly on the content of the transaction.</p>

<h4 id="protect-against-instruction-change-attacks">Protect Against “Instruction Change” Attacks</h4>

<p>Ledger applications live on a secure chip which is very limited in terms
of its memory and communication channel. This brings in an interesting
problem – the application might not be able to perform all its work in
a single request. Instead, the work will need to be spread over multiple
requests. Whenever this happens, the application needs to be protected
against attacker mixing multiple non-related (or even related) requests.</p>

<p>If your application contains at least one instruction which works over
multiple APDU exchanges (e.g., having <code class="language-plaintext highlighter-rouge">P1_INIT/P1_CONTINUE</code> flag in the
standard application “terminology”), you have to protect it from
interference. Common attack scenarios:</p>

<h5 id="example-two-multi-apdu-instructions">Example: Two multi-APDU instructions</h5>

<p>Let’s say you have SignTx and SignMessage, both sharing the same global
<code class="language-plaintext highlighter-rouge">hash</code> variable, both instructions working over multiple APDU
exchanges.The attacker might now call</p>

<ol>
  <li>SignMessage(INIT)</li>
  <li>SignTx(INIT)</li>
  <li>SignMessage(CONTINUE) with data (no finish yet)</li>
  <li>SignTx(CONTINUE) with data (finish)</li>
</ol>

<p>At this point, the global memory might be in an inconsistent state (for
example, the SignTx hash does contain a different hash than it should
be). This might lead to an easy attack.</p>

<h5 id="example-single-multi-apdu-instruction">Example: Single multi-APDU instruction</h5>

<p>Even if you have only a single instruction with multiple APDU exchanges,
an attacker might gain some leverage. Let’s say you have roughly</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">pubkey_ctx</span> <span class="p">{</span>
  <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="n">bip32_path</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">bip32_path_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sign_ctx</span> <span class="p">{</span>
  <span class="n">hash_ctx</span> <span class="n">hash</span><span class="p">;</span>
  <span class="c1">// some other data</span>
<span class="p">}</span>

<span class="k">union</span> <span class="p">{</span>
  <span class="n">pubkey_ctx</span> <span class="n">pubkey</span><span class="p">;</span>
  <span class="n">sign_ctx</span> <span class="n">signTx</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ctx</span><span class="p">;</span>
</code></pre></div></div>

<p>To overwrite the hash context with an exact chosen value.</p>

<h5 id="example-self-attack-on-a-single-multi-apdu-instruction">Example: “Self”-attack on a single multi-APDU instruction</h5>

<p>You don’t even need two instructions to perform a variation of the
attack. Suppose your code goes along these lines</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">signTx</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">==</span> <span class="n">P1_INIT</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">initialize_half_of_my_state</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">some_bad_input</span><span class="p">)</span> <span class="n">THROW</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
    <span class="n">initialize_rest_of_the_state</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// do something</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Assuming that you do not reset state on exceptions, this might happen</p>

<ol>
  <li>signTx(INIT, valid data)</li>
  <li>signTx(CONTINUE, valid data)</li>
  <li>signTx(INIT, data which throws)</li>
  <li>signTx(CONTINUE, more data)</li>
</ol>

<p>An attacker now managed to reset half of your state (maybe tx length)
but not the rest of it (maybe tx hash) which might allow it to attack
your code.</p>

<p>Obviously, there are many variations of this basic scheme and an utmost
care needs to be taken here. The recommendation here is:</p>

<ol>
  <li>Do not allow mixing of instructions</li>
  <li>Within instruction, keep an explicit state machine of what is
allowed to happen next)</li>
  <li>Clear memory on exceptions</li>
</ol>

<h4 id="use-explicit-state-machines">Use explicit state machines</h4>

<p>Whenever a host is required to perform certain actions in a specific
order, be sure to explicitly track the state and verify that the next
step is consistent. Good examples of what might need to be checked</p>

<ol>
  <li>If host claims some number of tx inputs/outputs, make sure you
receive exactly that amount, not more and not less</li>
  <li>If the host needs to send multiple transaction inputs and outputs
and you have to process inputs before outputs, make sure the host
cannot send additional input after it received an output.</li>
  <li>Check that once you finished an action (signing), the attacker
cannot resume with additional data (which might be empty). This is
important, because usually signing “closes” some hash contexts (or
destroy some other data) and re-running
<code class="language-plaintext highlighter-rouge">SignTx(CONTINUE, empty data)</code> might, therefore, yield either crash
or produce a signature of some different data. In general, after
finishing a request you should wipe the context variable</li>
  <li>If you do not reset UI after sending APDU (for example, because you
displayed an address and now you are waiting for another APDU
containing tx amount), make sure your button handlers fire just once
– a user might press the buttons multiple times. A general
recommendation would be to always reset UI with APDU response.
Additionally, you can guard your app against itself (and against bad
SDK) with tracking whether it should be in IO/UI phase and assert on
it in APDU/UI handlers.</li>
</ol>

<p>An (somewhat contrived) example of problematic button handlers</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">handle_sign_message</span><span class="p">(...)</span> <span class="p">{</span>
  <span class="p">...</span> <span class="c1">// validations</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_last_apdu</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cx_hash</span><span class="p">(</span><span class="n">CX_CONTINUE</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span> 
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_part</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">flags</span> <span class="o">*=</span> <span class="n">IO_ASYNCH</span><span class="p">;</span>
    <span class="n">display_tx_prompt</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">io_seproxyhal_touch_tx_ok</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// for some reason we modify ctx state here</span>
  <span class="n">cx_hash</span><span class="p">(</span><span class="n">CX_LAST</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_part</span><span class="p">);</span>
  <span class="n">sign</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">last_part</span><span class="p">);</span>
  <span class="c1">// now do io_exchange</span>

  <span class="c1">// Warning: this might throw (host might do something weird with USB)</span>
  <span class="c1">// -&gt; user will press the button second time</span>
  <span class="c1">// -&gt; we do another round of cx_hash -&gt; efficiently signing</span>
  <span class="n">io_exchange</span><span class="p">(....);</span>
  <span class="c1">// now reset UI</span>
  <span class="n">ui_idle</span><span class="p">();</span> <span class="c1">// &lt;-- this line resets button callback</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A fully resilient solution would be</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">display_tx_prompt</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">tx_prompt_handled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
   <span class="p">...</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">io_seproxyhal_touch_tx_ok</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">tx_prompt_handled</span><span class="p">);</span>
  <span class="n">tx_prompt_handled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">io_seproxyhal_touch_tx_cancel</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">tx_prompt_handled</span><span class="p">);</span>
  <span class="n">tx_prompt_handled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But such a solution is needed only if tx_ok or tx_cancel modify
context/global variables before calling ui_idle(). (As a side note, if
your__ok()/__cancel() handler both 1) do not check whether the
memory is cleared, but 2) clear the memory inside the handler; make sure
that memclear happens after calling ui_idle()).</p>

<p>Note: If not guarded properly, an attacker might try a following line of
attack:</p>

<ol>
  <li>Send transaction which is not what user wanted</li>
  <li>User realizes that the transaction is wrong and presses reject</li>
  <li>Attacker hogs <code class="language-plaintext highlighter-rouge">io_exchange</code> (presumably by doing some bad things to
USB communication)</li>
  <li>User tries again a few more times, thinks that the UI is broken and
the app hanged. The callbacks are fired again and again but
<code class="language-plaintext highlighter-rouge">io_exchange</code> still throws</li>
  <li>At this point in time, a desperate user might click on “confirm”
button to unblock the UI. If an attacker can guess this time, she
can un-hog USB and receive confirm callback</li>
</ol>


                        
                            <!-- FC
                            <div class="share uk-text-center uk-margin-medium-top">
    
        <a class="uk-link-muted" href="https://twitter.com/intent/tweet?text=Developing Secure Ledger Apps&url=http://localhost:4000/docs/NA/a_security_guidelines/&via=&related=" rel="nofollow" target="_blank" title="Share on Twitter" onclick="window.open(this.href, 'twitter', 'width=550,height=235');return false;"><span data-uk-icon="icon: twitter; ratio: 1.2"></span></a>
    
    
        <a class="uk-link-muted uk-margin-small-left" href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2Fdocs%2FNA%2Fa_security_guidelines%2F" rel="nofollow" target="_blank" title="Share on Facebook" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;"><span data-uk-icon="icon: facebook; ratio: 1.2"></span></a>
    
</div>
                            -->
                        
                    </div>

                    

                    <hr class="uk-margin-medium">

                    


  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  



                    <div class="uk-margin-large-top">
    <h3>Related Docs</h3>

    
    
    

    <ul class="uk-list link-secondary">
    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    
    </ul>
</div>


                    
                </article>

                <script>
                    // Table of contents scroll to
                    UIkit.scroll('#markdown-toc a', {
                        duration: 400,
                        offset: 120
                    });
                </script>

            </div>

    </div>
</div>


    <div id="offcanvas-docs" data-uk-offcanvas="overlay: true">
    <div class="uk-offcanvas-bar">

        <button class="uk-offcanvas-close" type="button" data-uk-close></button>

        
        <h5 class="uk-margin-top">Getting Started</h5>
        <ul class="uk-nav uk-nav-default doc-nav">
        
          
          
          <li class=""><a href="/docs/TMPL/installation/">Theme installation</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/setup/">Basic theme setup</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/navigation/">Navigation bar</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/footer/">Footer options</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/posts/">Creating your first post in Jekyll</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/docs/">Creating docs posts</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/comments/">Enabling comments (via Disqus)</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/analytics/">Google Analytics</a></li>
        
        </ul>
        
        <h5 class="uk-margin-top">Theme Features</h5>
        <ul class="uk-nav uk-nav-default doc-nav">
        
          
          
          <li class=""><a href="/docs/TMPL/hero/">Hero page header</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/boxes/">Category boxes section</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/featured/">Fearured docs section</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/videos/">Video lightbox boxes section</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/faq/">Frequently asked questions section</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/team/">Team members section</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/cta/">Call to action section</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/changelog/">Creating a changelog</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/contact/">Contact form (via FormSpree)</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/media/">Adding media to post and doc content</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/toc/">Adding table of contents to docs</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/alerts/">Adding alerts to content</a></li>
        
        </ul>
        
        <h5 class="uk-margin-top">Customization</h5>
        <ul class="uk-nav uk-nav-default doc-nav">
        
          
          
          <li class=""><a href="/docs/TMPL/translation/">Translation</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/customize/">Customization</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/development/">Development</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/sources/">Sources and credits</a></li>
        
        </ul>
        
        <h5 class="uk-margin-top">Help</h5>
        <ul class="uk-nav uk-nav-default doc-nav">
        
          
          
          <li class=""><a href="/docs/TMPL/support/">Contacting support</a></li>
        
        </ul>
        

    </div>
</div>


    <div id="offcanvas" data-uk-offcanvas="flip: true; overlay: true">
    <div class="uk-offcanvas-bar">

        <a class="uk-logo uk-margin-small-bottom" href="/">Ledger Developer pages</a>
     
        <button class="uk-offcanvas-close" type="button" data-uk-close></button>
      
        <ul class="uk-nav uk-nav-primary uk-margin-top">
            
                

                

                
                    <li><a href="/" >Home</a></li>
                
            
                

                

                
                    <li><a href="/docs/TMPL/installation" >Docs</a></li>
                
            
                

                

                
                    <li><a href="/blog/" >Blog</a></li>
                
            
                

                

                
                    <li><a href="/changelog-timeline/" >Changelog</a></li>
                
            
                

                

                
                    <li><div class="uk-navbar-item"><a class="uk-button uk-button-success" href="/contact/" >Contact</a></div></li>
                
            
        </ul>

        <div class="uk-margin-top uk-text-center">
            <div data-uk-grid class="uk-child-width-auto uk-grid-small uk-flex-center uk-grid">
                
<div class="uk-first-column">
    <a href="https://twitter.com/" data-uk-icon="icon: twitter" class="uk-icon-link uk-icon" target="_blank"></a>
</div>


<div>
    <a href="https://www.facebook.com/" data-uk-icon="icon: facebook" class="uk-icon-link uk-icon" target="_blank"></a>
</div>




<div>
    <a href="https://www.instagram.com/" data-uk-icon="icon: instagram" class="uk-icon-link uk-icon" target="_blank"></a>
</div>





<div>
    <a href="https://vimeo.com/" data-uk-icon="icon: vimeo" class="uk-icon-link uk-icon" target="_blank"></a>
</div>






            </div>
        </div>

    </div>
</div>


    
        <footer class="uk-section uk-text-center uk-text-muted">
    <div class="uk-container uk-container-small">

        <div>
            <ul class="uk-subnav uk-flex-center">
                
                    
                    
                    
                        <li><a href="/" >Home</a></li>
                    
                
                    
                    
                    
                        <li><a href="/blog/" >Blog</a></li>
                    
                
                    
                    
                    
                        <li><a href="/contact/" >Contact</a></li>
                    
                
            </ul>
        </div>
        <div class="uk-margin-medium">
            <div data-uk-grid class="uk-child-width-auto uk-grid-small uk-flex-center uk-grid">
                
                
<div class="uk-first-column">
    <a href="https://twitter.com/" data-uk-icon="icon: twitter" class="uk-icon-link uk-icon" target="_blank"></a>
</div>


<div>
    <a href="https://www.facebook.com/" data-uk-icon="icon: facebook" class="uk-icon-link uk-icon" target="_blank"></a>
</div>




<div>
    <a href="https://www.instagram.com/" data-uk-icon="icon: instagram" class="uk-icon-link uk-icon" target="_blank"></a>
</div>





<div>
    <a href="https://vimeo.com/" data-uk-icon="icon: vimeo" class="uk-icon-link uk-icon" target="_blank"></a>
</div>






                
            </div>
        </div>
        <div class="uk-margin-medium uk-text-small copyright link-secondary">Made by <a href="https://ledger.com/">Ledger</a> France</div>

    </div>
</footer>

    

    

    

    </body>

</html>
