<!DOCTYPE html>
<html lang="en">

    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>BOLOS Features | Ledger Developer pages</title>
<meta name="generator" content="Jekyll v3.9.1" />
<meta property="og:title" content="BOLOS Features" />
<meta name="author" content="pscott" />
<meta property="og:locale" content="en" />
<meta name="description" content="Sections in this article Introduction Management of Cryptographic Secrets Passphrases in BOLOS Attestation Anti-Tampering with Attestation Endorsement &amp; Application Attestation Attestation Chain of Trust Secure Channel Introduction In this section, we’ll discuss some of the features that are built into BOLOS. These features are available through the dashboard app &lt;dashboard&gt; and / or can be used by userspace applications. Management of Cryptographic Secrets There are two important cryptographic secrets that are stored and managed by BOLOS that will be discussed in this section: the Device keypair (which is generated in-factory) and the BIP 32 master node &lt;/bg_master_seed&gt; (which is derived from the user’s BIP 39 mnemonic seed). Both of these secrets are stored by BOLOS and are not directly accessible to applications for security reasons. The Device keypair can be used indirectly by applications for purposes of application attestation &lt;endorsement&gt;. Applications can derive secrets from the BIP 32 master node using a system call to BOLOS, provided the app was given the appropriate permissions when loaded onto the device. Passphrases in BOLOS Since firmware version 1.3 on the Ledger Nano S, BOLOS allows users to load multiple BIP 39 passphrases onto the device at once. As described in the previous chapter &lt;/bg_master_seed&gt;, passphrases are a method to add additional entropy to the BIP 39 master seed in order to completely change the HD tree &lt;/bg_hd_keys&gt;. Users can set a temporary passphrase which is activated until the device is disconnected, or store a passphrase on the device by attaching it to a PIN. When a passphrase is attached to a PIN, it is only activated when the user unlocks the device using the PIN corresponding to that passphrase. See our Help Center article on the advanced passphrase options for more information about using passphrases. When a passphrase is activated, the binary seed derived according to BIP 39 is changed and as such the entire HD tree is changed. This means that using a different passphrase causes applications that derive information from the HD tree (like cryptocurrency wallet applications) to derive entirely different information (different cryptocurrency addresses will be generated). Attestation Attestation is a process used by Ledger devices to prove that they are a genuine Ledger device, and not a knock-off or fake version. It can be used by BOLOS when connecting to a host computer to prove that the device has not been tampered with. It can also be used by applications to prove that they are running on a genuine Ledger device. BOLOS also supports endorsement of the device by third parties (called Owners &lt;Owner&gt;) for attestation purposes. Anti-Tampering with Attestation Ledger devices are protected from interdiction attacks (being tampered with while en route from Ledger’s warehouses to your home) due to anti-tampering technology built into the firmware. Using attestation, the authenticity of the device is verified in software every time you plug it into one of the Ledger Chrome applications. When all Ledger devices are provisioned in the factory, they first generate a unique Device public-private keypair. The Device’s public key is then signed by Ledger’s Issuer key to create an Issuer Certificate which is stored in the device. This certificate is a digital seal of authenticity of the Ledger device. By providing the Device’s public key and Issuer Certificate, the device can prove that it is a genuine Ledger device. When the Ledger device connects to one of the Ledger Chrome applications, the device uses the Issuer Certificate to prove that it is an authentic device (this takes place during establishment of the Secure Channel &lt;secure-channel&gt;, as we’ll discuss later in this section). If an attacker created a clone of the device running rogue firmware, this attestation process would fail and the device would be rejected as non-genuine. It is impossible for an attacker to replace the firmware on the device and have it pass attestation without having a Device private key and the corresponding Issuer Certificate, signed by Ledger. It is incredibly unlikely for the Device private key to become compromised, because the Secure Element is designed to be a stronghold against such physical attacks. It is theoretically possible to extract the private key, but only with great expense and time, so only an organization such as the NSA could do it. Tip For more information about the benefits of Ledger&#39;s use of a Secure Element for verifying device authenticity, see our blog post [How to protect hardware wallets against tampering](https://www.ledger.com/how-to-protect-hardware-wallets-against-tampering/) (though keep in mind that not all of the information in this article applies to Ledger&#39;s latest products). Endorsement &amp; Application Attestation As discussed in the previous subsection, the Device private key can be used to prove authenticity of a Ledger device. However, direct access to the device private key is limited to BOLOS, so it can’t be directly utilized by individual applications on the device (to avoid compromising the key). However, applications can indirectly use the Device private key for attestation purposes by generating attestation keypairs. Attestation keypairs can be generated on demand by the user for applications to use. An attestation key can be setup using the endorsementSetup.py or endorsementSetupLedger.py Python loader scripts. When generating an attestation keypair, the host computer connects to the dashboard application and initiates a Secure Channel &lt;secure-channel&gt; before instructing the device to create an attestation keypair. The device generates a new attestation keypair and signs it using the Device private key to create a Device Certificate. The device then returns the attestation public key, the Device Certificate, and the Issuer Certificate over the Secure Channel to the host. The host, which may be Ledger or a third party, then signs the attestation public key with an Owner private key, thus creating an Owner Certificate which is sent back over the Secure Channel and stored by the device (in this way, the Owner “endorses” the authenticity of the device). The device can then prove that the attestation key belongs to a genuine Ledger device using the Device Certificate and the Issuer Certificate, and that the attestation key is trusted by the Owner using the Owner Certificate. The attestation keys are not accessible to apps directly, instead BOLOS provides attestation functionality to userspace applications through cryptographic primitives available as system calls. There are two different Endorsement Schemes available to applications (Endorsement Scheme #1 and Endorsement Scheme #2). When creating an attestation keypair, the user must choose which scheme the keypair shall belong to. Applications can then use that keypair by using the cryptographic primitives offered for the appropriate Endorsement Scheme. Endorsement Scheme #1 offers two cryptographic primitives: os_endorsement_key1_get_app_secret(...) Derive a secret from the attestation private key and the hash of the running application. os_endorsement_key1_sign_data(...) Sign a message concatenated with the hash of the running application using the attestation private key (this signature can be verified using verifyEndorsement1.py). Endorsement Scheme #2 offers a single cryptographic primitive: os_endorsement_key2_derive_sign_data(...) Sign a message using a private key derived from the attestation private key and the hash of the running application (this signature can be verified using verifyEndorsement2.py). For an example of how these features may be used, check out blue-app-otherdime and this blog post which discusses the app in detail. Attestation Chain of Trust The chain of trust for Ledger&#39;s attestation model This diagram shows the chain of trust of our attestation model. All data signed by the attestation keys can be trusted to have been signed by an authentic Ledger device. This is because the Device Certificate is proof that the attestation keys belong to a device, and the Issuer Certificate is proof that the device is genuine. Additionally, the Owner Certificate is proof that the attestation keys are trusted by Owner (which may be Ledger or a third party). Secure Channel Throughout the standard device lifecycle, it is possible for a host computer to establish a Secure Channel with a device to verify its authenticity and to securely exchange secrets with it. As discussed in anti-tampering, the authenticity of a Ledger device can be verified when it connects to a host computer by requesting the device’s Issuer Certificate, which is signed by Ledger. This is done when establishing a Secure Channel with the device. However, the Secure Channel is not only a means to verify the authenticity of a Ledger device, it also allows the host computer to establish an encrypted communication channel with the device. Only the dashboard application &lt;dashboard&gt; is able to establish a Secure Channel with the host computer, as doing so requires access to the Device private key. The Secure Channel protocol is built on top of the APDU protocol used to communicate with the device over USB. As such, the protocol consists of a series of Command APDUs being sent from the host computer, and then associated Response APDUs being sent back from the device, with a one-to-one correspondence. The Secure Channel exists between two parties: the Signer and the Device. The Signer is the remote host connecting to the device. This may be the Issuer (Ledger) connecting to the device through our APIs, a `Custom Certificate Authority ` connecting to the device using a previously `enrolled Custom CA public key `, or another end-user using a randomly generated keypair. When establishing the Secure Channel, both parties (the Signer and the Device) generate an ephemeral keypair which is later used to calculate a shared secret using ECDH for encrypted communications between the two parties. Both parties prove that they trust their respective ephemeral public keys by each providing a certificate chain. These certificate chains incorporate both a Signer nonce and a Device nonce to avoid reuse of the certificates by an eavesdropper. If the root certificate in the certificate chain provided by the Signer is signed by a party that is trusted by the device, then the device grants the remote host special permissions after establishing the Secure Channel. For example, if the root certificate in the Signer&#39;s certificate chain is signed by a previously enrolled Custom CA keypair or Ledger&#39;s Issuer keypair, then the host can add or remove apps from the device without the user&#39;s confirmation. The process of establishing a Secure Channel is illustrated in the following diagram. An admittedly not-so-simple diagram of the Secure Channel protocol handshake In the above diagram, during segment (6), the Device provides a Signer serial. The Signer serial is a number stored by the device which identifies the specific Issuer keypair used to sign the device&#39;s Issuer Certificate, as Ledger does not use the same Issuer keypair for every device. The Signer certificate chain is generated, sent to the device, and verified from (7) to (11). The Device certificate chain is generated, sent to the Signer, and verified from (12) to (16). In this example, both certificate chains consist of two certificates. The root certificate in the Signer certificate chain is self-signed. The final certificate in the Signer certificate chain is signed by the Signer and verifies the authenticity of the Signer ephemeral public key. The root certificate in the Device certificate chain is the Issuer Certificate (as such, verifying this certificate implicitly verifies the authenticity of the device). The final certificate in the Device certificate chain is signed by the Device and verifies the authenticity of the Device ephemeral public key. ### Custom CA Public Key Enrollment `Custom Certificate Authorities ` have the option to generate a keypair (using `genCAPair.py`) and enroll their public key onto the device (using `setupCustomCA.py`). Enrolling the Custom CA public key onto the device gives them the following special privileges: - The Custom CA can open authenticated `Secure Channels ` with the device (using the `--rootPrivateKey` option of the Python loader scripts). - The Custom CA can sign applications (using `signApp.py`) to create a signature which can be used to avoid the user confirmation when loading the app on the device. This feature may be used by BOLOS application developers to simplify the development process, but it is intended to be much wider in scope than that. This feature may also be used by third party companies to give their own application manager permissions to manage the device without needing user confirmation on every action. ### Parties Involved in our Model Below is a definition of all of the parties involved in our public key cryptography model. Device Device Certificate The meaning of this term should be quite self-evident, however in our public key cryptography model it has a distinct meaning. Each Device has a **unique** public-private keypair that is known **only to that device**. In the factory, the Device generates it&#39;s own public-private keypair. The Device&#39;s private key is not known by Ledger. The Device public-private key pair can be used to sign certificates. Issuer Issuer Certificate The Issuer is the party that initially provisions the `Device`. This party is always Ledger. The Issuer has a public-private keypair that can be used to sign Issuer Certificates. Note that Ledger uses multiple Issuer keypairs, not just one. Owner Owner Certificate An Owner is simply a party that owns and / or verifies the authenticity of a Ledger device. An Owner has a public-private keypair that can be used to sign certificates. A single `Device` can have zero or more Owners, and the Owner doesn&#39;t have to be Ledger. The device uses Owner Certificates exclusively for the purposes of `application attestation `. Custom CA Custom CA Certificate A Custom Certificate Authority has a public-private keypair, where the public key is `enrolled on the device `. The Custom CA&#39;s private key can then be used to establish authenticated `Secure Channels ` with the device and sign applications. &gt; A Custom CA may be a BOLOS application developer or a third party &gt; company that would like to give their application manager special &gt; administration permissions with a BOLOS device. &lt;/div&gt;" />
<meta property="og:description" content="Sections in this article Introduction Management of Cryptographic Secrets Passphrases in BOLOS Attestation Anti-Tampering with Attestation Endorsement &amp; Application Attestation Attestation Chain of Trust Secure Channel Introduction In this section, we’ll discuss some of the features that are built into BOLOS. These features are available through the dashboard app &lt;dashboard&gt; and / or can be used by userspace applications. Management of Cryptographic Secrets There are two important cryptographic secrets that are stored and managed by BOLOS that will be discussed in this section: the Device keypair (which is generated in-factory) and the BIP 32 master node &lt;/bg_master_seed&gt; (which is derived from the user’s BIP 39 mnemonic seed). Both of these secrets are stored by BOLOS and are not directly accessible to applications for security reasons. The Device keypair can be used indirectly by applications for purposes of application attestation &lt;endorsement&gt;. Applications can derive secrets from the BIP 32 master node using a system call to BOLOS, provided the app was given the appropriate permissions when loaded onto the device. Passphrases in BOLOS Since firmware version 1.3 on the Ledger Nano S, BOLOS allows users to load multiple BIP 39 passphrases onto the device at once. As described in the previous chapter &lt;/bg_master_seed&gt;, passphrases are a method to add additional entropy to the BIP 39 master seed in order to completely change the HD tree &lt;/bg_hd_keys&gt;. Users can set a temporary passphrase which is activated until the device is disconnected, or store a passphrase on the device by attaching it to a PIN. When a passphrase is attached to a PIN, it is only activated when the user unlocks the device using the PIN corresponding to that passphrase. See our Help Center article on the advanced passphrase options for more information about using passphrases. When a passphrase is activated, the binary seed derived according to BIP 39 is changed and as such the entire HD tree is changed. This means that using a different passphrase causes applications that derive information from the HD tree (like cryptocurrency wallet applications) to derive entirely different information (different cryptocurrency addresses will be generated). Attestation Attestation is a process used by Ledger devices to prove that they are a genuine Ledger device, and not a knock-off or fake version. It can be used by BOLOS when connecting to a host computer to prove that the device has not been tampered with. It can also be used by applications to prove that they are running on a genuine Ledger device. BOLOS also supports endorsement of the device by third parties (called Owners &lt;Owner&gt;) for attestation purposes. Anti-Tampering with Attestation Ledger devices are protected from interdiction attacks (being tampered with while en route from Ledger’s warehouses to your home) due to anti-tampering technology built into the firmware. Using attestation, the authenticity of the device is verified in software every time you plug it into one of the Ledger Chrome applications. When all Ledger devices are provisioned in the factory, they first generate a unique Device public-private keypair. The Device’s public key is then signed by Ledger’s Issuer key to create an Issuer Certificate which is stored in the device. This certificate is a digital seal of authenticity of the Ledger device. By providing the Device’s public key and Issuer Certificate, the device can prove that it is a genuine Ledger device. When the Ledger device connects to one of the Ledger Chrome applications, the device uses the Issuer Certificate to prove that it is an authentic device (this takes place during establishment of the Secure Channel &lt;secure-channel&gt;, as we’ll discuss later in this section). If an attacker created a clone of the device running rogue firmware, this attestation process would fail and the device would be rejected as non-genuine. It is impossible for an attacker to replace the firmware on the device and have it pass attestation without having a Device private key and the corresponding Issuer Certificate, signed by Ledger. It is incredibly unlikely for the Device private key to become compromised, because the Secure Element is designed to be a stronghold against such physical attacks. It is theoretically possible to extract the private key, but only with great expense and time, so only an organization such as the NSA could do it. Tip For more information about the benefits of Ledger&#39;s use of a Secure Element for verifying device authenticity, see our blog post [How to protect hardware wallets against tampering](https://www.ledger.com/how-to-protect-hardware-wallets-against-tampering/) (though keep in mind that not all of the information in this article applies to Ledger&#39;s latest products). Endorsement &amp; Application Attestation As discussed in the previous subsection, the Device private key can be used to prove authenticity of a Ledger device. However, direct access to the device private key is limited to BOLOS, so it can’t be directly utilized by individual applications on the device (to avoid compromising the key). However, applications can indirectly use the Device private key for attestation purposes by generating attestation keypairs. Attestation keypairs can be generated on demand by the user for applications to use. An attestation key can be setup using the endorsementSetup.py or endorsementSetupLedger.py Python loader scripts. When generating an attestation keypair, the host computer connects to the dashboard application and initiates a Secure Channel &lt;secure-channel&gt; before instructing the device to create an attestation keypair. The device generates a new attestation keypair and signs it using the Device private key to create a Device Certificate. The device then returns the attestation public key, the Device Certificate, and the Issuer Certificate over the Secure Channel to the host. The host, which may be Ledger or a third party, then signs the attestation public key with an Owner private key, thus creating an Owner Certificate which is sent back over the Secure Channel and stored by the device (in this way, the Owner “endorses” the authenticity of the device). The device can then prove that the attestation key belongs to a genuine Ledger device using the Device Certificate and the Issuer Certificate, and that the attestation key is trusted by the Owner using the Owner Certificate. The attestation keys are not accessible to apps directly, instead BOLOS provides attestation functionality to userspace applications through cryptographic primitives available as system calls. There are two different Endorsement Schemes available to applications (Endorsement Scheme #1 and Endorsement Scheme #2). When creating an attestation keypair, the user must choose which scheme the keypair shall belong to. Applications can then use that keypair by using the cryptographic primitives offered for the appropriate Endorsement Scheme. Endorsement Scheme #1 offers two cryptographic primitives: os_endorsement_key1_get_app_secret(...) Derive a secret from the attestation private key and the hash of the running application. os_endorsement_key1_sign_data(...) Sign a message concatenated with the hash of the running application using the attestation private key (this signature can be verified using verifyEndorsement1.py). Endorsement Scheme #2 offers a single cryptographic primitive: os_endorsement_key2_derive_sign_data(...) Sign a message using a private key derived from the attestation private key and the hash of the running application (this signature can be verified using verifyEndorsement2.py). For an example of how these features may be used, check out blue-app-otherdime and this blog post which discusses the app in detail. Attestation Chain of Trust The chain of trust for Ledger&#39;s attestation model This diagram shows the chain of trust of our attestation model. All data signed by the attestation keys can be trusted to have been signed by an authentic Ledger device. This is because the Device Certificate is proof that the attestation keys belong to a device, and the Issuer Certificate is proof that the device is genuine. Additionally, the Owner Certificate is proof that the attestation keys are trusted by Owner (which may be Ledger or a third party). Secure Channel Throughout the standard device lifecycle, it is possible for a host computer to establish a Secure Channel with a device to verify its authenticity and to securely exchange secrets with it. As discussed in anti-tampering, the authenticity of a Ledger device can be verified when it connects to a host computer by requesting the device’s Issuer Certificate, which is signed by Ledger. This is done when establishing a Secure Channel with the device. However, the Secure Channel is not only a means to verify the authenticity of a Ledger device, it also allows the host computer to establish an encrypted communication channel with the device. Only the dashboard application &lt;dashboard&gt; is able to establish a Secure Channel with the host computer, as doing so requires access to the Device private key. The Secure Channel protocol is built on top of the APDU protocol used to communicate with the device over USB. As such, the protocol consists of a series of Command APDUs being sent from the host computer, and then associated Response APDUs being sent back from the device, with a one-to-one correspondence. The Secure Channel exists between two parties: the Signer and the Device. The Signer is the remote host connecting to the device. This may be the Issuer (Ledger) connecting to the device through our APIs, a `Custom Certificate Authority ` connecting to the device using a previously `enrolled Custom CA public key `, or another end-user using a randomly generated keypair. When establishing the Secure Channel, both parties (the Signer and the Device) generate an ephemeral keypair which is later used to calculate a shared secret using ECDH for encrypted communications between the two parties. Both parties prove that they trust their respective ephemeral public keys by each providing a certificate chain. These certificate chains incorporate both a Signer nonce and a Device nonce to avoid reuse of the certificates by an eavesdropper. If the root certificate in the certificate chain provided by the Signer is signed by a party that is trusted by the device, then the device grants the remote host special permissions after establishing the Secure Channel. For example, if the root certificate in the Signer&#39;s certificate chain is signed by a previously enrolled Custom CA keypair or Ledger&#39;s Issuer keypair, then the host can add or remove apps from the device without the user&#39;s confirmation. The process of establishing a Secure Channel is illustrated in the following diagram. An admittedly not-so-simple diagram of the Secure Channel protocol handshake In the above diagram, during segment (6), the Device provides a Signer serial. The Signer serial is a number stored by the device which identifies the specific Issuer keypair used to sign the device&#39;s Issuer Certificate, as Ledger does not use the same Issuer keypair for every device. The Signer certificate chain is generated, sent to the device, and verified from (7) to (11). The Device certificate chain is generated, sent to the Signer, and verified from (12) to (16). In this example, both certificate chains consist of two certificates. The root certificate in the Signer certificate chain is self-signed. The final certificate in the Signer certificate chain is signed by the Signer and verifies the authenticity of the Signer ephemeral public key. The root certificate in the Device certificate chain is the Issuer Certificate (as such, verifying this certificate implicitly verifies the authenticity of the device). The final certificate in the Device certificate chain is signed by the Device and verifies the authenticity of the Device ephemeral public key. ### Custom CA Public Key Enrollment `Custom Certificate Authorities ` have the option to generate a keypair (using `genCAPair.py`) and enroll their public key onto the device (using `setupCustomCA.py`). Enrolling the Custom CA public key onto the device gives them the following special privileges: - The Custom CA can open authenticated `Secure Channels ` with the device (using the `--rootPrivateKey` option of the Python loader scripts). - The Custom CA can sign applications (using `signApp.py`) to create a signature which can be used to avoid the user confirmation when loading the app on the device. This feature may be used by BOLOS application developers to simplify the development process, but it is intended to be much wider in scope than that. This feature may also be used by third party companies to give their own application manager permissions to manage the device without needing user confirmation on every action. ### Parties Involved in our Model Below is a definition of all of the parties involved in our public key cryptography model. Device Device Certificate The meaning of this term should be quite self-evident, however in our public key cryptography model it has a distinct meaning. Each Device has a **unique** public-private keypair that is known **only to that device**. In the factory, the Device generates it&#39;s own public-private keypair. The Device&#39;s private key is not known by Ledger. The Device public-private key pair can be used to sign certificates. Issuer Issuer Certificate The Issuer is the party that initially provisions the `Device`. This party is always Ledger. The Issuer has a public-private keypair that can be used to sign Issuer Certificates. Note that Ledger uses multiple Issuer keypairs, not just one. Owner Owner Certificate An Owner is simply a party that owns and / or verifies the authenticity of a Ledger device. An Owner has a public-private keypair that can be used to sign certificates. A single `Device` can have zero or more Owners, and the Owner doesn&#39;t have to be Ledger. The device uses Owner Certificates exclusively for the purposes of `application attestation `. Custom CA Custom CA Certificate A Custom Certificate Authority has a public-private keypair, where the public key is `enrolled on the device `. The Custom CA&#39;s private key can then be used to establish authenticated `Secure Channels ` with the device and sign applications. &gt; A Custom CA may be a BOLOS application developer or a third party &gt; company that would like to give their application manager special &gt; administration permissions with a BOLOS device. &lt;/div&gt;" />
<link rel="canonical" href="http://localhost:4000/docs/NA/b_features/" />
<meta property="og:url" content="http://localhost:4000/docs/NA/b_features/" />
<meta property="og:site_name" content="Ledger Developer pages" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-04-22T15:38:24+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="BOLOS Features" />
<script type="application/ld+json">
{"datePublished":"2021-04-22T15:38:24+02:00","description":"Sections in this article Introduction Management of Cryptographic Secrets Passphrases in BOLOS Attestation Anti-Tampering with Attestation Endorsement &amp; Application Attestation Attestation Chain of Trust Secure Channel Introduction In this section, we’ll discuss some of the features that are built into BOLOS. These features are available through the dashboard app &lt;dashboard&gt; and / or can be used by userspace applications. Management of Cryptographic Secrets There are two important cryptographic secrets that are stored and managed by BOLOS that will be discussed in this section: the Device keypair (which is generated in-factory) and the BIP 32 master node &lt;/bg_master_seed&gt; (which is derived from the user’s BIP 39 mnemonic seed). Both of these secrets are stored by BOLOS and are not directly accessible to applications for security reasons. The Device keypair can be used indirectly by applications for purposes of application attestation &lt;endorsement&gt;. Applications can derive secrets from the BIP 32 master node using a system call to BOLOS, provided the app was given the appropriate permissions when loaded onto the device. Passphrases in BOLOS Since firmware version 1.3 on the Ledger Nano S, BOLOS allows users to load multiple BIP 39 passphrases onto the device at once. As described in the previous chapter &lt;/bg_master_seed&gt;, passphrases are a method to add additional entropy to the BIP 39 master seed in order to completely change the HD tree &lt;/bg_hd_keys&gt;. Users can set a temporary passphrase which is activated until the device is disconnected, or store a passphrase on the device by attaching it to a PIN. When a passphrase is attached to a PIN, it is only activated when the user unlocks the device using the PIN corresponding to that passphrase. See our Help Center article on the advanced passphrase options for more information about using passphrases. When a passphrase is activated, the binary seed derived according to BIP 39 is changed and as such the entire HD tree is changed. This means that using a different passphrase causes applications that derive information from the HD tree (like cryptocurrency wallet applications) to derive entirely different information (different cryptocurrency addresses will be generated). Attestation Attestation is a process used by Ledger devices to prove that they are a genuine Ledger device, and not a knock-off or fake version. It can be used by BOLOS when connecting to a host computer to prove that the device has not been tampered with. It can also be used by applications to prove that they are running on a genuine Ledger device. BOLOS also supports endorsement of the device by third parties (called Owners &lt;Owner&gt;) for attestation purposes. Anti-Tampering with Attestation Ledger devices are protected from interdiction attacks (being tampered with while en route from Ledger’s warehouses to your home) due to anti-tampering technology built into the firmware. Using attestation, the authenticity of the device is verified in software every time you plug it into one of the Ledger Chrome applications. When all Ledger devices are provisioned in the factory, they first generate a unique Device public-private keypair. The Device’s public key is then signed by Ledger’s Issuer key to create an Issuer Certificate which is stored in the device. This certificate is a digital seal of authenticity of the Ledger device. By providing the Device’s public key and Issuer Certificate, the device can prove that it is a genuine Ledger device. When the Ledger device connects to one of the Ledger Chrome applications, the device uses the Issuer Certificate to prove that it is an authentic device (this takes place during establishment of the Secure Channel &lt;secure-channel&gt;, as we’ll discuss later in this section). If an attacker created a clone of the device running rogue firmware, this attestation process would fail and the device would be rejected as non-genuine. It is impossible for an attacker to replace the firmware on the device and have it pass attestation without having a Device private key and the corresponding Issuer Certificate, signed by Ledger. It is incredibly unlikely for the Device private key to become compromised, because the Secure Element is designed to be a stronghold against such physical attacks. It is theoretically possible to extract the private key, but only with great expense and time, so only an organization such as the NSA could do it. Tip For more information about the benefits of Ledger&#39;s use of a Secure Element for verifying device authenticity, see our blog post [How to protect hardware wallets against tampering](https://www.ledger.com/how-to-protect-hardware-wallets-against-tampering/) (though keep in mind that not all of the information in this article applies to Ledger&#39;s latest products). Endorsement &amp; Application Attestation As discussed in the previous subsection, the Device private key can be used to prove authenticity of a Ledger device. However, direct access to the device private key is limited to BOLOS, so it can’t be directly utilized by individual applications on the device (to avoid compromising the key). However, applications can indirectly use the Device private key for attestation purposes by generating attestation keypairs. Attestation keypairs can be generated on demand by the user for applications to use. An attestation key can be setup using the endorsementSetup.py or endorsementSetupLedger.py Python loader scripts. When generating an attestation keypair, the host computer connects to the dashboard application and initiates a Secure Channel &lt;secure-channel&gt; before instructing the device to create an attestation keypair. The device generates a new attestation keypair and signs it using the Device private key to create a Device Certificate. The device then returns the attestation public key, the Device Certificate, and the Issuer Certificate over the Secure Channel to the host. The host, which may be Ledger or a third party, then signs the attestation public key with an Owner private key, thus creating an Owner Certificate which is sent back over the Secure Channel and stored by the device (in this way, the Owner “endorses” the authenticity of the device). The device can then prove that the attestation key belongs to a genuine Ledger device using the Device Certificate and the Issuer Certificate, and that the attestation key is trusted by the Owner using the Owner Certificate. The attestation keys are not accessible to apps directly, instead BOLOS provides attestation functionality to userspace applications through cryptographic primitives available as system calls. There are two different Endorsement Schemes available to applications (Endorsement Scheme #1 and Endorsement Scheme #2). When creating an attestation keypair, the user must choose which scheme the keypair shall belong to. Applications can then use that keypair by using the cryptographic primitives offered for the appropriate Endorsement Scheme. Endorsement Scheme #1 offers two cryptographic primitives: os_endorsement_key1_get_app_secret(...) Derive a secret from the attestation private key and the hash of the running application. os_endorsement_key1_sign_data(...) Sign a message concatenated with the hash of the running application using the attestation private key (this signature can be verified using verifyEndorsement1.py). Endorsement Scheme #2 offers a single cryptographic primitive: os_endorsement_key2_derive_sign_data(...) Sign a message using a private key derived from the attestation private key and the hash of the running application (this signature can be verified using verifyEndorsement2.py). For an example of how these features may be used, check out blue-app-otherdime and this blog post which discusses the app in detail. Attestation Chain of Trust The chain of trust for Ledger&#39;s attestation model This diagram shows the chain of trust of our attestation model. All data signed by the attestation keys can be trusted to have been signed by an authentic Ledger device. This is because the Device Certificate is proof that the attestation keys belong to a device, and the Issuer Certificate is proof that the device is genuine. Additionally, the Owner Certificate is proof that the attestation keys are trusted by Owner (which may be Ledger or a third party). Secure Channel Throughout the standard device lifecycle, it is possible for a host computer to establish a Secure Channel with a device to verify its authenticity and to securely exchange secrets with it. As discussed in anti-tampering, the authenticity of a Ledger device can be verified when it connects to a host computer by requesting the device’s Issuer Certificate, which is signed by Ledger. This is done when establishing a Secure Channel with the device. However, the Secure Channel is not only a means to verify the authenticity of a Ledger device, it also allows the host computer to establish an encrypted communication channel with the device. Only the dashboard application &lt;dashboard&gt; is able to establish a Secure Channel with the host computer, as doing so requires access to the Device private key. The Secure Channel protocol is built on top of the APDU protocol used to communicate with the device over USB. As such, the protocol consists of a series of Command APDUs being sent from the host computer, and then associated Response APDUs being sent back from the device, with a one-to-one correspondence. The Secure Channel exists between two parties: the Signer and the Device. The Signer is the remote host connecting to the device. This may be the Issuer (Ledger) connecting to the device through our APIs, a `Custom Certificate Authority ` connecting to the device using a previously `enrolled Custom CA public key `, or another end-user using a randomly generated keypair. When establishing the Secure Channel, both parties (the Signer and the Device) generate an ephemeral keypair which is later used to calculate a shared secret using ECDH for encrypted communications between the two parties. Both parties prove that they trust their respective ephemeral public keys by each providing a certificate chain. These certificate chains incorporate both a Signer nonce and a Device nonce to avoid reuse of the certificates by an eavesdropper. If the root certificate in the certificate chain provided by the Signer is signed by a party that is trusted by the device, then the device grants the remote host special permissions after establishing the Secure Channel. For example, if the root certificate in the Signer&#39;s certificate chain is signed by a previously enrolled Custom CA keypair or Ledger&#39;s Issuer keypair, then the host can add or remove apps from the device without the user&#39;s confirmation. The process of establishing a Secure Channel is illustrated in the following diagram. An admittedly not-so-simple diagram of the Secure Channel protocol handshake In the above diagram, during segment (6), the Device provides a Signer serial. The Signer serial is a number stored by the device which identifies the specific Issuer keypair used to sign the device&#39;s Issuer Certificate, as Ledger does not use the same Issuer keypair for every device. The Signer certificate chain is generated, sent to the device, and verified from (7) to (11). The Device certificate chain is generated, sent to the Signer, and verified from (12) to (16). In this example, both certificate chains consist of two certificates. The root certificate in the Signer certificate chain is self-signed. The final certificate in the Signer certificate chain is signed by the Signer and verifies the authenticity of the Signer ephemeral public key. The root certificate in the Device certificate chain is the Issuer Certificate (as such, verifying this certificate implicitly verifies the authenticity of the device). The final certificate in the Device certificate chain is signed by the Device and verifies the authenticity of the Device ephemeral public key. ### Custom CA Public Key Enrollment `Custom Certificate Authorities ` have the option to generate a keypair (using `genCAPair.py`) and enroll their public key onto the device (using `setupCustomCA.py`). Enrolling the Custom CA public key onto the device gives them the following special privileges: - The Custom CA can open authenticated `Secure Channels ` with the device (using the `--rootPrivateKey` option of the Python loader scripts). - The Custom CA can sign applications (using `signApp.py`) to create a signature which can be used to avoid the user confirmation when loading the app on the device. This feature may be used by BOLOS application developers to simplify the development process, but it is intended to be much wider in scope than that. This feature may also be used by third party companies to give their own application manager permissions to manage the device without needing user confirmation on every action. ### Parties Involved in our Model Below is a definition of all of the parties involved in our public key cryptography model. Device Device Certificate The meaning of this term should be quite self-evident, however in our public key cryptography model it has a distinct meaning. Each Device has a **unique** public-private keypair that is known **only to that device**. In the factory, the Device generates it&#39;s own public-private keypair. The Device&#39;s private key is not known by Ledger. The Device public-private key pair can be used to sign certificates. Issuer Issuer Certificate The Issuer is the party that initially provisions the `Device`. This party is always Ledger. The Issuer has a public-private keypair that can be used to sign Issuer Certificates. Note that Ledger uses multiple Issuer keypairs, not just one. Owner Owner Certificate An Owner is simply a party that owns and / or verifies the authenticity of a Ledger device. An Owner has a public-private keypair that can be used to sign certificates. A single `Device` can have zero or more Owners, and the Owner doesn&#39;t have to be Ledger. The device uses Owner Certificates exclusively for the purposes of `application attestation `. Custom CA Custom CA Certificate A Custom Certificate Authority has a public-private keypair, where the public key is `enrolled on the device `. The Custom CA&#39;s private key can then be used to establish authenticated `Secure Channels ` with the device and sign applications. &gt; A Custom CA may be a BOLOS application developer or a third party &gt; company that would like to give their application manager special &gt; administration permissions with a BOLOS device. &lt;/div&gt;","dateModified":"2021-04-22T15:38:24+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/docs/NA/b_features/"},"url":"http://localhost:4000/docs/NA/b_features/","author":{"@type":"Person","name":"pscott"},"@type":"BlogPosting","headline":"BOLOS Features","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <meta property="og:image" content="http://localhost:4000/uploads/"/>
  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="shortcut icon" type="image/png" href="/uploads/favicon.png" >
  <link rel="alternate" type="application/rss+xml" title="Ledger Developer pages" href="/feed.xml">
  <script src="/assets/js/main.js"></script>
  
    <script>
function searchResults(form) {

    var currentItem = null;
    var search = document.getElementById(form);
    var results = document.getElementById(form + "-results");
    var toggle = document.getElementById(form + "-toggle");

    function removeActive() {
        for (i = 0; i < results.children.length; i++) {
            results.children[i].classList.remove("uk-background-muted");
        }
    }

    // Detect all clicks on the document
    document.addEventListener("click", function(event) {

        var isClickSearch = false;
        var isClickResults = false;
        var isClickSearchToggle = false;

        if (search !== null) {
            isClickSearch = search.contains(event.target);
        }

        if (results !== null) {
            isClickResults = results.contains(event.target);
        }

        if (toggle !== null) {
            isClickSearchToggle = toggle.contains(event.target);
        }

        if (isClickSearch || isClickSearchToggle) {
            results.style.display = "block";
        }        

        if (!isClickResults && !isClickSearch && !isClickSearchToggle) {
            results.style.display = "none";
        }        
        
    });    

    results.addEventListener("mouseover", function(event) {

        removeActive();
        event.target.parentElement.classList.add("uk-background-muted");
        currentItem = null;

    });

    results.addEventListener("mouseout", function(event) {
        event.target.parentElement.classList.remove("uk-background-muted");
    });


    search.addEventListener("keyup", function(event) {

        var resultItems = results.children;
        var resultCount = results.children.length;
                                
        if (event.keyCode === 40) {

            if (currentItem < (resultCount - 1)) {
                if (currentItem === null) {
                    currentItem = 0;
                } else {
                    removeActive();
                    currentItem++;
                }
                removeActive();
                resultItems[currentItem].classList.add("uk-background-muted");
            }
            
        } else if (event.keyCode === 38) {

            if (currentItem > 0) {
                if (currentItem === null) {
                    currentItem = 0;
                } else {
                    removeActive();
                    currentItem--;
                }
                removeActive();
                resultItems[currentItem].classList.add("uk-background-muted");
            }

        } else if (event.keyCode === 13) {

            resultItems[currentItem].children[0].click();

        }

    });

}
</script>
  
  
  
<script src="http://127.0.0.1:35729/livereload.js"></script></head>

    <body>

    
        <div data-uk-sticky="animation: uk-animation-slide-top; sel-target: .uk-navbar-container; cls-active: uk-navbar-sticky; cls-inactive: uk-navbar-transparent; top: 200">
    <nav class="uk-navbar-container">
        <div class="uk-container">
            <div data-uk-navbar>
                <div class="uk-navbar-left">
                    <a class="uk-navbar-item uk-logo uk-visible@m" href="/">Ledger Developer pages</a>
                    
                        <a class="uk-navbar-toggle uk-hidden@m" href="#offcanvas-docs" data-uk-toggle><span data-uk-navbar-toggle-icon></span> <span class="uk-margin-small-left">Docs</span></a>
                    

                    <ul class="uk-navbar-nav uk-visible@m">
                        
                            
                            
                            
                                
                                    
                                        <li><a href="/docs/00_header/" >Creating content</a></li>
                                                                                                        
                                
                            
                        
                            
                            
                            
                                
                                    
                                        <li><a href="/docs/00_header/" >Tools & Frameworks</a></li>
                                                                                                        
                                
                            
                        
                            
                            
                            
                                
                                    
                                        <li><a href="/docs/00_header/" >Release notes</a></li>
                                                                                                        
                                
                            
                        
                            
                            
                            
                                
                                    
                                        <li><a href="/docs/00_header/" >Tutorials</a></li>
                                                                                                        
                                
                            
                        
                            
                            
                            
                                
                                    
                                        <li><a href="#">_Old</a>
                                        
                                            <div class="uk-navbar-dropdown">
                                                <ul class="uk-nav uk-navbar-dropdown-nav">
                                                    
                                                    
                                                        
                                                        
                                                        <li><a href="/docs/TMPL/installation/">Template docs</a></li>
                                                    
                                                    
                                                    
                                                        
                                                        
                                                        <li><a href="/blog/">Blog</a></li>
                                                    
                                                    
                                                    
                                                        <li class="uk-nav-header">Changelogs</li>
                                                    
                                                    
                                                </ul>
                                            </div>
                                        
                                        </li>
                                                                                                        
                                
                            
                        
                    </ul>
                </div>
                <div class="uk-navbar-center uk-hidden@m">
                    <a class="uk-navbar-item uk-logo" href="/">Ledger Developer pages</a>
                </div>
                <div class="uk-navbar-right">
                    
                        
                            <div>
                                <a id="search-navbar-toggle" class="uk-navbar-toggle" uk-search-icon href="#"></a>
                                <div class="uk-drop uk-background-default uk-border-rounded" uk-drop="mode: click; pos: left-center; offset: 0">
                                    <form class="uk-search uk-search-navbar uk-width-1-1" onsubmit="return false;">
                                        <input id="search-navbar" class="uk-search-input" type="search" placeholder="Search for answers" autofocus autocomplete="off">
                                    </form>
                                    <ul id="search-navbar-results" class="uk-position-absolute uk-width-1-1 uk-list"></ul>
                                </div>
                            </div>
                            <script>
                            SimpleJekyllSearch({
                                searchInput: document.getElementById('search-navbar'),
                                resultsContainer: document.getElementById('search-navbar-results'),
                                noResultsText: '<li class="no-results">No results found</li>',
                                searchResultTemplate: '<li><a href="{url}">{title}</a></li>',
                                json: "/search.json"
                            });
                            searchResults("search-navbar");
                            </script>
                        
                    

                    <ul class="uk-navbar-nav uk-visible@m">
                        
                    </ul>

                    
                        <a class="uk-navbar-toggle uk-hidden@m" href="#offcanvas" data-uk-toggle><span data-uk-navbar-toggle-icon></span> <span class="uk-margin-small-left">Menu</span></a>
                    

                </div>
            </div>
        </div>
    </nav>
</div>
    

    <div class="uk-section">
    <div class="uk-container">
        <div class="uk-grid-large" data-uk-grid>

            <div class="sidebar-fixed-width uk-visible@m">
                <div class="sidebar-docs uk-position-fixed uk-margin-top">
                    
                    <h5>Background Information</h5>
                    <ul class="uk-nav uk-nav-default doc-nav">
                    
                      
                      
                      <li class=""><a href="/docs/NA/bg_introduction/">Introduction</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/bg_personal_security_devices/">Personal Security Devices</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/bg_master_seed/">The Master Seed</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/bg_hd_keys/">HD Key Generation</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/bg_hd_use_cases/">Applications for HD Trees</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/bg_application_isolation/">Application Isolation</a></li>
                    
                    </ul>
                    
                    <h5>BOLOS Platform</h5>
                    <ul class="uk-nav uk-nav-default doc-nav">
                    
                      
                      
                      <li class=""><a href="/docs/NA/b_introduction/">Introduction</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/b_overview/">Overview</a></li>
                    
                      
                      
                      <li class="uk-active"><a href="/docs/NA/b_features/">BOLOS Features</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/b_hardware_architecture/">Hardware Architecture</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/b_application_environment/">Application Environment</a></li>
                    
                    </ul>
                    
                    <h5>Userspace Development</h5>
                    <ul class="uk-nav uk-nav-default doc-nav">
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_introduction/">Introduction</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_setup/">Setting it up</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_writing_apps/">Writing Apps</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_display_management/">Display Management</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_advanced_display_management/">Advanced display management</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_low_level_display_management/">Low-level display management</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_syscalls/">Interaction Between BOLOS and Apps</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_application_structure/">Application Structure and I/O</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_memory/">Persistent Storage and PIC</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_alignment/">Memory alignment</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_troubleshooting/">Common Pitfalls and Troubleshooting</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_debugging/">Application Debug</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/u_speculos/">Emulating devices with Speculos</a></li>
                    
                    </ul>
                    
                    <h5>Additional Resources</h5>
                    <ul class="uk-nav uk-nav-default doc-nav">
                    
                      
                      
                      <li class=""><a href="/docs/NA/a_publishing_an_app/">Publishing an Application</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/a_external_docs/">External Documentation</a></li>
                    
                      
                      
                      <li class=""><a href="/docs/NA/a_security_guidelines/">Developing Secure Ledger Apps</a></li>
                    
                    </ul>
                    
                </div>
            </div>

            <div class="uk-width-1-1 uk-width-expand@m">

                <article class="uk-article">

                    <h1 class="uk-article-title">BOLOS Features</h1>

                    <p class="uk-text-lead uk-text-muted">Secrets, Passphrases and Attestations</p>

                    <div class="uk-article-meta uk-margin-top uk-margin-medium-bottom uk-flex uk-flex-middle">
                        


  
  <img class="uk-border-circle avatar" src="http://localhost:4000/uploads/avatar-pscott.jpg" alt="pscott">


<div>
  
    Written by <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">pscott</span></span><br>
  
  <time datetime="" itemprop="datePublished">
    
    
  </time>
</div>
                    </div>

                    <div class="article-content link-primary">
                        <h4 class="no_toc" id="sections-in-this-article">Sections in this article</h4>
<ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a>    <ul>
      <li><a href="#management-of-cryptographic-secrets" id="markdown-toc-management-of-cryptographic-secrets">Management of Cryptographic Secrets</a>        <ul>
          <li><a href="#passphrases-in-bolos" id="markdown-toc-passphrases-in-bolos">Passphrases in BOLOS</a></li>
        </ul>
      </li>
      <li><a href="#attestation" id="markdown-toc-attestation">Attestation</a>        <ul>
          <li><a href="#anti-tampering-with-attestation" id="markdown-toc-anti-tampering-with-attestation">Anti-Tampering with Attestation</a></li>
          <li><a href="#endorsement--application-attestation" id="markdown-toc-endorsement--application-attestation">Endorsement &amp; Application Attestation</a></li>
          <li><a href="#attestation-chain-of-trust" id="markdown-toc-attestation-chain-of-trust">Attestation Chain of Trust</a></li>
        </ul>
      </li>
      <li><a href="#secure-channel" id="markdown-toc-secure-channel">Secure Channel</a></li>
    </ul>
  </li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>In this section, we’ll discuss some of the features that are built into
BOLOS. These features are available through the
<code class="language-plaintext highlighter-rouge">dashboard app &lt;dashboard&gt;</code> and / or can be used by userspace
applications.</p>

<h3 id="management-of-cryptographic-secrets">Management of Cryptographic Secrets</h3>

<p>There are two important cryptographic secrets that are stored and
managed by BOLOS that will be discussed in this section: the <code class="language-plaintext highlighter-rouge">Device</code>
keypair (which is generated in-factory) and the <code class="language-plaintext highlighter-rouge">BIP 32 master node
&lt;/bg_master_seed&gt;</code> (which is derived from the user’s BIP 39
mnemonic seed). Both of these secrets are stored by BOLOS and are not
directly accessible to applications for security reasons. The Device
keypair can be used indirectly by applications for purposes of
<code class="language-plaintext highlighter-rouge">application attestation &lt;endorsement&gt;</code>. Applications can derive secrets
from the BIP 32 master node using a system call to BOLOS, provided the
app was given the appropriate permissions when loaded onto the device.</p>

<h4 id="passphrases-in-bolos">Passphrases in BOLOS</h4>

<p>Since firmware version 1.3 on the Ledger Nano S, BOLOS allows users to
load multiple <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#from-mnemonic-to-seed">BIP 39
passphrases</a>
onto the device at once. As described in <code class="language-plaintext highlighter-rouge">the previous chapter
&lt;/bg_master_seed&gt;</code>, passphrases are a method to add additional
entropy to the BIP 39 master seed in order to completely change the
<code class="language-plaintext highlighter-rouge">HD tree &lt;/bg_hd_keys&gt;</code>. Users can set a temporary passphrase which is
activated until the device is disconnected, or store a passphrase on the
device by attaching it to a PIN. When a passphrase is attached to a PIN,
it is only activated when the user unlocks the device using the PIN
corresponding to that passphrase. See our <a href="https://support.ledger.com/hc/en-us/articles/115005214529-Advanced-passphrase-security">Help Center article on the
advanced passphrase
options</a>
for more information about using passphrases.</p>

<p>When a passphrase is activated, the binary seed derived according to BIP
39 is changed and as such the entire HD tree is changed. This means that
using a different passphrase causes applications that derive information
from the HD tree (like cryptocurrency wallet applications) to derive
entirely different information (different cryptocurrency addresses will
be generated).</p>

<h3 id="attestation">Attestation</h3>

<p>Attestation is a process used by Ledger devices to prove that they are a
genuine Ledger device, and not a knock-off or fake version. It can be
used by BOLOS when connecting to a host computer to prove that the
device has not been tampered with. It can also be used by applications
to prove that they are running on a genuine Ledger device. BOLOS also
supports endorsement of the device by third parties (called
<code class="language-plaintext highlighter-rouge">Owners &lt;Owner&gt;</code>) for attestation purposes.</p>

<h4 id="anti-tampering-with-attestation">Anti-Tampering with Attestation</h4>

<figure>
<img src="../Images/wallet_not_genuine.png" class="align-center" />
</figure>

<p>Ledger devices are protected from interdiction attacks (being tampered
with while en route from Ledger’s warehouses to your home) due to
anti-tampering technology built into the firmware. Using attestation,
the authenticity of the device is verified in software every time you
plug it into one of the Ledger Chrome applications.</p>

<p>When all Ledger devices are provisioned in the factory, they first
generate a unique <code class="language-plaintext highlighter-rouge">Device</code> public-private keypair. The Device’s public
key is then signed by Ledger’s <code class="language-plaintext highlighter-rouge">Issuer</code> key to create an Issuer
Certificate which is stored in the device. This certificate is a digital
seal of authenticity of the Ledger device. By providing the Device’s
public key and Issuer Certificate, the device can prove that it is a
genuine Ledger device.</p>

<p>When the Ledger device connects to one of the Ledger Chrome
applications, the device uses the Issuer Certificate to prove that it is
an authentic device (this takes place during establishment of the
<code class="language-plaintext highlighter-rouge">Secure Channel &lt;secure-channel&gt;</code>, as we’ll discuss later in this
section). If an attacker created a clone of the device running rogue
firmware, this attestation process would fail and the device would be
rejected as non-genuine. It is impossible for an attacker to replace the
firmware on the device and have it pass attestation without having a
Device private key and the corresponding Issuer Certificate, signed by
Ledger.</p>

<p>It is incredibly unlikely for the Device private key to become
compromised, because the Secure Element is designed to be a stronghold
against such physical attacks. It is theoretically possible to extract
the private key, but only with great expense and time, so only an
organization such as the NSA could do it.</p>

<div class="tip">

<div class="title">

Tip

</div>

For more information about the benefits of Ledger's use of a Secure
Element for verifying device authenticity, see our blog post [How to
protect hardware wallets against
tampering](https://www.ledger.com/how-to-protect-hardware-wallets-against-tampering/)
(though keep in mind that not all of the information in this article
applies to Ledger's latest products).

</div>

<h4 id="endorsement--application-attestation">Endorsement &amp; Application Attestation</h4>

<p>As discussed in the previous subsection, the <code class="language-plaintext highlighter-rouge">Device</code> private key can be
used to prove authenticity of a Ledger device. However, direct access to
the device private key is limited to BOLOS, so it can’t be directly
utilized by individual applications on the device (to avoid compromising
the key). However, applications can indirectly use the Device private
key for attestation purposes by generating attestation keypairs.</p>

<p>Attestation keypairs can be generated on demand by the user for
applications to use. An attestation key can be setup using the
<code class="language-plaintext highlighter-rouge">endorsementSetup.py</code> or <code class="language-plaintext highlighter-rouge">endorsementSetupLedger.py</code> Python loader
scripts. When generating an attestation keypair, the host computer
connects to the dashboard application and initiates a
<code class="language-plaintext highlighter-rouge">Secure Channel &lt;secure-channel&gt;</code> before instructing the device to
create an attestation keypair. The device generates a new attestation
keypair and signs it using the <code class="language-plaintext highlighter-rouge">Device</code> private key to create a Device
Certificate. The device then returns the attestation public key, the
Device Certificate, and the Issuer Certificate over the Secure Channel
to the host. The host, which may be Ledger or a third party, then signs
the attestation public key with an <code class="language-plaintext highlighter-rouge">Owner</code> private key, thus creating an
Owner Certificate which is sent back over the Secure Channel and stored
by the device (in this way, the Owner “endorses” the authenticity of the
device). The device can then prove that the attestation key belongs to a
genuine Ledger device using the Device Certificate and the Issuer
Certificate, and that the attestation key is trusted by the Owner using
the Owner Certificate.</p>

<p>The attestation keys are not accessible to apps directly, instead BOLOS
provides attestation functionality to userspace applications through
cryptographic primitives available as system calls. There are two
different Endorsement Schemes available to applications (Endorsement
Scheme #1 and Endorsement Scheme #2). When creating an attestation
keypair, the user must choose which scheme the keypair shall belong to.
Applications can then use that keypair by using the cryptographic
primitives offered for the appropriate Endorsement Scheme.</p>

<p>Endorsement Scheme #1 offers two cryptographic primitives:</p>

<p><code class="language-plaintext highlighter-rouge">os_endorsement_key1_get_app_secret(...)</code><br />
Derive a secret from the attestation private key and the hash of the
running application.</p>

<p><code class="language-plaintext highlighter-rouge">os_endorsement_key1_sign_data(...)</code><br />
Sign a message concatenated with the hash of the running application
using the attestation private key (this signature can be verified using
<code class="language-plaintext highlighter-rouge">verifyEndorsement1.py</code>).</p>

<p>Endorsement Scheme #2 offers a single cryptographic primitive:</p>

<p><code class="language-plaintext highlighter-rouge">os_endorsement_key2_derive_sign_data(...)</code><br />
Sign a message using a private key derived from the attestation private
key and the hash of the running application (this signature can be
verified using <code class="language-plaintext highlighter-rouge">verifyEndorsement2.py</code>).</p>

<p>For an example of how these features may be used, check out
<a href="https://github.com/LedgerHQ/blue-app-otherdime">blue-app-otherdime</a> and
<a href="https://blog.ledger.co/attestation-redux-proving-code-execution-on-the-ledger-platform-fd11ab0f7c19">this blog
post</a>
which discusses the app in detail.</p>

<h4 id="attestation-chain-of-trust">Attestation Chain of Trust</h4>

<figure>
<img src="../Images/chain_of_trust.png" class="align-center" alt="The chain of trust for Ledger&#39;s attestation model" /><figcaption aria-hidden="true">The chain of trust for Ledger's attestation model</figcaption>
</figure>

<p>This diagram shows the chain of trust of our attestation model. All data
signed by the attestation keys can be trusted to have been signed by an
authentic Ledger device. This is because the Device Certificate is proof
that the attestation keys belong to a device, and the Issuer Certificate
is proof that the device is genuine. Additionally, the Owner Certificate
is proof that the attestation keys are trusted by Owner (which may be
Ledger or a third party).</p>

<h3 id="secure-channel">Secure Channel</h3>

<p>Throughout the standard device lifecycle, it is possible for a host
computer to establish a Secure Channel with a device to verify its
authenticity and to securely exchange secrets with it.</p>

<p>As discussed in <code class="language-plaintext highlighter-rouge">anti-tampering</code>, the authenticity of a Ledger device
can be verified when it connects to a host computer by requesting the
device’s <code class="language-plaintext highlighter-rouge">Issuer Certificate</code>, which is signed by Ledger. This is done
when establishing a Secure Channel with the device. However, the Secure
Channel is not only a means to verify the authenticity of a Ledger
device, it also allows the host computer to establish an encrypted
communication channel with the device. Only the
<code class="language-plaintext highlighter-rouge">dashboard application &lt;dashboard&gt;</code> is able to establish a Secure
Channel with the host computer, as doing so requires access to the
<code class="language-plaintext highlighter-rouge">Device</code> private key.</p>

<p>The Secure Channel protocol is built on top of the APDU protocol used to
communicate with the device over USB. As such, the protocol consists of
a series of Command APDUs being sent from the host computer, and then
associated Response APDUs being sent back from the device, with a
one-to-one correspondence. The Secure Channel exists between two
parties: the Signer and the Device. The Signer is the remote host
connecting to the device. This may be the Issuer (Ledger) connecting to
the device through our APIs, a `Custom Certificate Authority</p>
<Custom CA="">` connecting to the device using a previously
`enrolled Custom
CA public key <custom-ca-enrollment>`, or another end-user using a
randomly generated keypair.

When establishing the Secure Channel, both parties (the Signer and the
Device) generate an ephemeral keypair which is later used to calculate a
shared secret using ECDH for encrypted communications between the two
parties. Both parties prove that they trust their respective ephemeral
public keys by each providing a certificate chain. These certificate
chains incorporate both a Signer nonce and a Device nonce to avoid reuse
of the certificates by an eavesdropper. If the root certificate in the
certificate chain provided by the Signer is signed by a party that is
trusted by the device, then the device grants the remote host special
permissions after establishing the Secure Channel. For example, if the
root certificate in the Signer's certificate chain is signed by a
previously enrolled Custom CA keypair or Ledger's Issuer keypair, then
the host can add or remove apps from the device without the user's
confirmation.

The process of establishing a Secure Channel is illustrated in the
following diagram.

<figure>
<img src="../Images/secure_channel_protocol.png" class="align-center" alt="An admittedly not-so-simple diagram of the Secure Channel protocol handshake" /><figcaption aria-hidden="true">An admittedly not-so-simple diagram of the Secure Channel protocol handshake</figcaption>  
</figure>  
  
In the above diagram, during segment (6), the Device provides a Signer
serial. The Signer serial is a number stored by the device which
identifies the specific Issuer keypair used to sign the device's Issuer
Certificate, as Ledger does not use the same Issuer keypair for every
device.  
  
The Signer certificate chain is generated, sent to the device, and
verified from (7) to (11). The Device certificate chain is generated,
sent to the Signer, and verified from (12) to (16). In this example,
both certificate chains consist of two certificates. The root
certificate in the Signer certificate chain is self-signed. The final
certificate in the Signer certificate chain is signed by the Signer and
verifies the authenticity of the Signer ephemeral public key. The root
certificate in the Device certificate chain is the Issuer Certificate
(as such, verifying this certificate implicitly verifies the
authenticity of the device). The final certificate in the Device
certificate chain is signed by the Device and verifies the authenticity
of the Device ephemeral public key.  
  
### Custom CA Public Key Enrollment
  
`Custom Certificate Authorities <Custom CA="">` have the option to generate
a keypair (using `genCAPair.py`) and enroll their public key onto the
device (using `setupCustomCA.py`). Enrolling the Custom CA public key
onto the device gives them the following special privileges:  
  
-   The Custom CA can open authenticated
    `Secure Channels <secure-channel>` with the device (using the
    `--rootPrivateKey` option of the Python loader scripts).
-   The Custom CA can sign applications (using `signApp.py`) to create a
    signature which can be used to avoid the user confirmation when
    loading the app on the device.  

This feature may be used by BOLOS application developers to simplify the
development process, but it is intended to be much wider in scope than
that. This feature may also be used by third party companies to give
their own application manager permissions to manage the device without
needing user confirmation on every action.  

### Parties Involved in our Model  

Below is a definition of all of the parties involved in our public key
cryptography model.  

<div class="glossary">  

Device Device Certificate The meaning of this term should be quite
self-evident, however in our public key cryptography model it has a
distinct meaning. Each Device has a **unique** public-private keypair
that is known **only to that device**. In the factory, the Device
generates it's own public-private keypair. The Device's private key is
not known by Ledger. The Device public-private key pair can be used to
sign certificates.  

Issuer Issuer Certificate The Issuer is the party that initially
provisions the `Device`. This party is always Ledger. The Issuer has a
public-private keypair that can be used to sign Issuer Certificates.
Note that Ledger uses multiple Issuer keypairs, not just one.  

Owner Owner Certificate An Owner is simply a party that owns and / or
verifies the authenticity of a Ledger device. An Owner has a
public-private keypair that can be used to sign certificates. A single
`Device` can have zero or more Owners, and the Owner doesn't have to be
Ledger. The device uses Owner Certificates exclusively for the purposes
of `application attestation  
   <endorsement>`.

Custom CA Custom CA Certificate A Custom Certificate Authority has a
public-private keypair, where the public key is
`enrolled on the device <custom-ca-enrollment>`. The Custom CA's private
key can then be used to establish authenticated
`Secure Channels <secure-channel>` with the device and sign
applications.  

&gt; A Custom CA may be a BOLOS application developer or a third party
&gt; company that would like to give their application manager special
&gt; administration permissions with a BOLOS device.  

&lt;/div&gt;

</secure-channel></custom-ca-enrollment></endorsement></div></secure-channel></Custom></custom-ca-enrollment></Custom>

                        
                            <!-- FC
                            <div class="share uk-text-center uk-margin-medium-top">
    
        <a class="uk-link-muted" href="https://twitter.com/intent/tweet?text=BOLOS Features&url=http://localhost:4000/docs/NA/b_features/&via=&related=" rel="nofollow" target="_blank" title="Share on Twitter" onclick="window.open(this.href, 'twitter', 'width=550,height=235');return false;"><span data-uk-icon="icon: twitter; ratio: 1.2"></span></a>
    
    
        <a class="uk-link-muted uk-margin-small-left" href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2Fdocs%2FNA%2Fb_features%2F" rel="nofollow" target="_blank" title="Share on Facebook" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;"><span data-uk-icon="icon: facebook; ratio: 1.2"></span></a>
    
</div>
                            -->
                        
                    </div>

                    

                    <hr class="uk-margin-medium">

                    


  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  



                    <div class="uk-margin-large-top">
    <h3>Related Docs</h3>

    
    
    

    <ul class="uk-list link-secondary">
    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    

    
    

    

    

    
    </ul>
</div>


                    
                </article>

                <script>
                    // Table of contents scroll to
                    UIkit.scroll('#markdown-toc a', {
                        duration: 400,
                        offset: 120
                    });
                </script>

            </div>

    </div>
</div>


    <div id="offcanvas-docs" data-uk-offcanvas="overlay: true">
    <div class="uk-offcanvas-bar">

        <button class="uk-offcanvas-close" type="button" data-uk-close></button>

        
        <h5 class="uk-margin-top">Getting Started</h5>
        <ul class="uk-nav uk-nav-default doc-nav">
        
          
          
          <li class=""><a href="/docs/TMPL/installation/">Theme installation</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/setup/">Basic theme setup</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/navigation/">Navigation bar</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/footer/">Footer options</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/posts/">Creating your first post in Jekyll</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/docs/">Creating docs posts</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/comments/">Enabling comments (via Disqus)</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/analytics/">Google Analytics</a></li>
        
        </ul>
        
        <h5 class="uk-margin-top">Theme Features</h5>
        <ul class="uk-nav uk-nav-default doc-nav">
        
          
          
          <li class=""><a href="/docs/TMPL/hero/">Hero page header</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/boxes/">Category boxes section</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/featured/">Fearured docs section</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/videos/">Video lightbox boxes section</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/faq/">Frequently asked questions section</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/team/">Team members section</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/cta/">Call to action section</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/changelog/">Creating a changelog</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/contact/">Contact form (via FormSpree)</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/media/">Adding media to post and doc content</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/toc/">Adding table of contents to docs</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/alerts/">Adding alerts to content</a></li>
        
        </ul>
        
        <h5 class="uk-margin-top">Customization</h5>
        <ul class="uk-nav uk-nav-default doc-nav">
        
          
          
          <li class=""><a href="/docs/TMPL/translation/">Translation</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/customize/">Customization</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/development/">Development</a></li>
        
          
          
          <li class=""><a href="/docs/TMPL/sources/">Sources and credits</a></li>
        
        </ul>
        
        <h5 class="uk-margin-top">Help</h5>
        <ul class="uk-nav uk-nav-default doc-nav">
        
          
          
          <li class=""><a href="/docs/TMPL/support/">Contacting support</a></li>
        
        </ul>
        

    </div>
</div>


    <div id="offcanvas" data-uk-offcanvas="flip: true; overlay: true">
    <div class="uk-offcanvas-bar">

        <a class="uk-logo uk-margin-small-bottom" href="/">Ledger Developer pages</a>
     
        <button class="uk-offcanvas-close" type="button" data-uk-close></button>
      
        <ul class="uk-nav uk-nav-primary uk-margin-top">
            
                

                

                
                    <li><a href="/" >Home</a></li>
                
            
                

                

                
                    <li><a href="/docs/TMPL/installation" >Docs</a></li>
                
            
                

                

                
                    <li><a href="/blog/" >Blog</a></li>
                
            
                

                

                
                    <li><a href="/changelog-timeline/" >Changelog</a></li>
                
            
                

                

                
                    <li><div class="uk-navbar-item"><a class="uk-button uk-button-success" href="/contact/" >Contact</a></div></li>
                
            
        </ul>

        <div class="uk-margin-top uk-text-center">
            <div data-uk-grid class="uk-child-width-auto uk-grid-small uk-flex-center uk-grid">
                
<div class="uk-first-column">
    <a href="https://twitter.com/" data-uk-icon="icon: twitter" class="uk-icon-link uk-icon" target="_blank"></a>
</div>


<div>
    <a href="https://www.facebook.com/" data-uk-icon="icon: facebook" class="uk-icon-link uk-icon" target="_blank"></a>
</div>




<div>
    <a href="https://www.instagram.com/" data-uk-icon="icon: instagram" class="uk-icon-link uk-icon" target="_blank"></a>
</div>





<div>
    <a href="https://vimeo.com/" data-uk-icon="icon: vimeo" class="uk-icon-link uk-icon" target="_blank"></a>
</div>






            </div>
        </div>

    </div>
</div>


    
        <footer class="uk-section uk-text-center uk-text-muted">
    <div class="uk-container uk-container-small">

        <div>
            <ul class="uk-subnav uk-flex-center">
                
                    
                    
                    
                        <li><a href="/" >Home</a></li>
                    
                
                    
                    
                    
                        <li><a href="/blog/" >Blog</a></li>
                    
                
                    
                    
                    
                        <li><a href="/contact/" >Contact</a></li>
                    
                
            </ul>
        </div>
        <div class="uk-margin-medium">
            <div data-uk-grid class="uk-child-width-auto uk-grid-small uk-flex-center uk-grid">
                
                
<div class="uk-first-column">
    <a href="https://twitter.com/" data-uk-icon="icon: twitter" class="uk-icon-link uk-icon" target="_blank"></a>
</div>


<div>
    <a href="https://www.facebook.com/" data-uk-icon="icon: facebook" class="uk-icon-link uk-icon" target="_blank"></a>
</div>




<div>
    <a href="https://www.instagram.com/" data-uk-icon="icon: instagram" class="uk-icon-link uk-icon" target="_blank"></a>
</div>





<div>
    <a href="https://vimeo.com/" data-uk-icon="icon: vimeo" class="uk-icon-link uk-icon" target="_blank"></a>
</div>






                
            </div>
        </div>
        <div class="uk-margin-medium uk-text-small copyright link-secondary">Made by <a href="https://ledger.com/">Ledger</a> France</div>

    </div>
</footer>

    

    

    

    </body>

</html>
